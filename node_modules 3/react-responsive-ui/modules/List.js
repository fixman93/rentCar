'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.ListItem = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp2, _class2, _temp4;

exports.findItemIndexByValue = findItemIndexByValue;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _Divider = require('./Divider');

var _Divider2 = _interopRequireDefault(_Divider);

var _dom = require('./utility/dom');

var _focus = require('./utility/focus');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = _react2.default.PureComponent || _react2.default.Component;

var List = (_temp2 = _class = function (_PureComponent) {
	_inherits(List, _PureComponent);

	function List() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, List);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = List.__proto__ || Object.getPrototypeOf(List)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
			items: _this.props.items

			// `ref`s of all items currently rendered.
		}, _this.itemRefs = [], _this.input = '', _this.getFocusedItemIndex = function () {
			return _this.state.focusedItemIndex;
		}, _this.clearFocus = function () {
			return _this.focusItem();
		}, _this.unfocus = _this.clearFocus, _this.focus = function () {
			var focusedItemIndex = _this.state.focusedItemIndex;

			if (focusedItemIndex !== undefined) {
				return _this.focusItem(focusedItemIndex);
			}
			// // Focus the first focusable list item.
			// this.focusItem(this.getFirstFocusableItemIndex())
			_this.list.focus();
		}, _this.focusItem = function (focusedItemIndex) {
			var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
			var _this$props = _this.props,
			    onFocusItem = _this$props.onFocusItem,
			    shouldFocus = _this$props.shouldFocus;


			if (onFocusItem) {
				onFocusItem(focusedItemIndex, options);
			}

			_this.setState({
				// Focus the item.
				focusedItemIndex: focusedItemIndex,
				// Store the focused item value.
				// This is used for cases like autocomplete
				// where the list of options changes but
				// the focused option stays focused.
				focusedItemValue: focusedItemIndex === undefined ? undefined : _this.getItemValue(focusedItemIndex)
			}, function () {
				// Actually focus the item.
				if (focusedItemIndex !== undefined) {
					if (shouldFocus && _this._isMounted) {
						if (!(0, _focus.focus)(_this.itemRefs[focusedItemIndex])) {
							console.error('<List.Item/> #' + (focusedItemIndex + 1) + '\'s child component doesn\'t have a ".focus()" method.');
						}
					}
				}
			});
		}, _this.onKeyDown = function (event) {
			var _this$props2 = _this.props,
			    onKeyDown = _this$props2.onKeyDown,
			    children = _this$props2.children;
			var focusedItemIndex = _this.state.focusedItemIndex;


			if (onKeyDown) {
				onKeyDown(event);
			}

			if (event.defaultPrevented) {
				return;
			}

			if ((0, _dom.submitFormOnCtrlEnter)(event, _this.input)) {
				return;
			}

			if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
				return;
			}

			if (_react2.default.Children.count(children) > 0) {
				switch (event.keyCode) {
					// "Up" arrow.
					// Select the previous item (if present).
					case 38:
						event.preventDefault();

						var previousIndex = _this.getPreviousFocusableItemIndex();

						if (previousIndex !== undefined) {
							_this.focusItem(previousIndex, { interaction: true });
						}

						return;

					// "Down" arrow.
					// Select the next item (if present).
					case 40:
						event.preventDefault();

						var nextIndex = _this.getNextFocusableItemIndex();

						if (nextIndex !== undefined) {
							_this.focusItem(nextIndex, { interaction: true });
						}

						return;
				}
			}
		}, _this.onKeyPress = function (event) {
			var resetInputTimeout = _this.props.resetInputTimeout;

			var characters = event.char || String.fromCharCode(event.charCode);
			if (characters) {
				_this.input += characters;
				_this.onInput();
				clearTimeout(_this.resetInputTimer);
				_this.resetInputTimer = setTimeout(_this.resetInput, resetInputTimeout);
			}
		}, _this.resetInput = function () {
			return _this.input = '';
		}, _this.isInputInProgress = function () {
			return _this.input !== '';
		}, _this.onInputSpacebar = function () {
			if (_this.input) {
				_this.input += ' ';
			}
		}, _this.onItemFocus = function (event) {
			var expandable = _this.props.expandable;

			if (expandable) {
				return;
			}
			_this.onFocusIn();
		}, _this.onBlur = function (event) {
			var expandable = _this.props.expandable;

			if (expandable) {
				return;
			}
			clearTimeout(_this.blurTimer);
			var result = (0, _focus.onBlur)(event, _this.onFocusOut, function () {
				return _this.list;
			});
			if (typeof result === 'number') {
				_this.blurTimer = result;
			}
		}, _this.onFocusIn = function () {
			var onFocusIn = _this.props.onFocusIn;

			if (onFocusIn) {
				onFocusIn();
			}
			_this.setState({
				isFocused: true
			});
		}, _this.onFocusOut = function () {
			var value = _this.props.value;

			if (value === undefined) {
				_this.clearFocus();
			}
			_this.setState({
				isFocused: false
			});
		}, _this.isFocusableItemIndex = function (index) {
			return _this.itemRefs[index] !== undefined;
		}, _this.isFocusableItem = function (item) {
			return !isDivider(item);
		}, _this.storeListNode = function (node) {
			return _this.list = node;
		}, _this.storeItemRef = function (ref, i) {
			return _this.itemRefs[i] = ref;
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	// For select options list keyboard navigation via typing.


	_createClass(List, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			var highlightFirstItem = this.props.highlightFirstItem;


			if (highlightFirstItem) {
				this.focusItem(0);
			}

			this._isMounted = true;
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate(prevProps, prevState) {
			var _props = this.props,
			    value = _props.value,
			    items = _props.items,
			    children = _props.children,
			    highlightSelectedItem = _props.highlightSelectedItem,
			    highlightFirstItem = _props.highlightFirstItem;

			// If `items` property is supplied
			// then it's used to detect "on items changed" event.

			if (prevState.items && prevState.items !== items) {
				this.setState({ items: items });
				// `findItemIndexByValue()` must return `undefined` for "no such item".
				var selectedItemIndex = highlightSelectedItem ? findItemIndexByValue(value, children) : undefined;
				this.focusItem(selectedItemIndex === undefined ? highlightFirstItem ? 0 : undefined : selectedItemIndex);
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this._isMounted = false;
			clearTimeout(this.blurTimer);
			clearTimeout(this.resetInputTimer);
		}
	}, {
		key: 'chooseFocusedItem',
		value: function chooseFocusedItem() {
			var focusedItemIndex = this.state.focusedItemIndex;

			if (focusedItemIndex !== undefined) {
				var itemRef = this.itemRefs[focusedItemIndex];
				if (itemRef.click) {
					itemRef.click();
				}
			}
		}
		// Deprecated method name.


		// Focuses the list.

	}, {
		key: 'getFirstFocusableItemIndex',
		value: function getFirstFocusableItemIndex() {
			var i = 0;
			while (i < this.itemRefs.length) {
				if (this.itemRefs[i]) {
					return i;
				}
			}
		}
	}, {
		key: 'getItemValue',
		value: function getItemValue(index) {
			var children = this.props.children;

			var item = _react2.default.Children.toArray(children)[index];
			return item.props.value;
		}

		// Can be public API for programmatically focusing a certain `<List.Item/>`.

	}, {
		key: 'onInput',
		value: function onInput() {
			var children = this.props.children;

			var index = findItemIndexByLabel(this.input, children);
			if (index !== undefined) {
				this.focusItem(index);
			}
		}
	}, {
		key: 'getPreviousFocusableItemIndex',


		// Get the previous option (relative to the currently focused option)
		value: function getPreviousFocusableItemIndex() {
			var children = this.props.children;
			var focusedItemIndex = this.state.focusedItemIndex;


			if (focusedItemIndex === undefined) {
				focusedItemIndex = _react2.default.Children.count(children);
			}

			while (focusedItemIndex > 0) {
				focusedItemIndex--;
				if (this.isFocusableItemIndex(focusedItemIndex)) {
					return focusedItemIndex;
				}
			}
		}

		// Get the next option (relative to the currently focused option)

	}, {
		key: 'getNextFocusableItemIndex',
		value: function getNextFocusableItemIndex() {
			var children = this.props.children;
			var focusedItemIndex = this.state.focusedItemIndex;


			if (focusedItemIndex === undefined) {
				focusedItemIndex = -1;
			}

			while (focusedItemIndex < _react2.default.Children.count(children) - 1) {
				focusedItemIndex++;
				if (this.isFocusableItemIndex(focusedItemIndex)) {
					return focusedItemIndex;
				}
			}
		}

		// `this.list` is also being accessed from `<ScrollableList/>`.

	}, {
		key: 'render',
		value: function render() {
			var _this2 = this;

			var _props2 = this.props,
			    id = _props2.id,
			    expandable = _props2.expandable,
			    disabled = _props2.disabled,
			    tabbable = _props2.tabbable,
			    value = _props2.value,
			    hasOnChange = _props2.hasOnChange,
			    onChange = _props2.onChange,
			    onSelectItem = _props2.onSelectItem,
			    highlightSelectedItem = _props2.highlightSelectedItem,
			    createButtons = _props2.createButtons,
			    className = _props2.className,
			    style = _props2.style,
			    children = _props2.children;
			var role = this.props.role;
			var _state = this.state,
			    focusedItemIndex = _state.focusedItemIndex,
			    isFocused = _state.isFocused;

			// ARIA (accessibility) roles info:
			// https://www.w3.org/TR/wai-aria-practices/examples/listbox/listbox-collapsible.html

			if (!role && (onChange || onSelectItem)) {
				role = 'listbox';
			}

			// if (this.props['aria-hidden']) {
			// 	role = undefined
			// }

			// `tabIndex={ -1 }` makes the `<ul/>` focusable.
			// So that `<Expandable/>` doesn't collapse on click inside it (top, bottom).

			return _react2.default.createElement(
				'ul',
				{
					ref: this.storeListNode,
					id: id,
					role: role,
					'aria-label': this.props['aria-label'],
					'aria-hidden': this.props['aria-hidden'],
					'aria-required': this.props['aria-required'],
					'aria-invalid': this.props['aria-invalid'],
					onFocus: this.onFocusIn,
					onKeyDown: this.onKeyDown,
					onKeyPress: this.onKeyPress,
					tabIndex: -1,
					style: style,
					className: (0, _classnames2.default)(className, 'rrui__outline', 'rrui__list', {
						'rrui__list--focus': isFocused
					}) },
				_react2.default.Children.map(children, function (item, i) {
					// Workaround for `react-hot-loader`.
					// https://github.com/gaearon/react-hot-loader#checking-element-types
					if (item.type.displayName !== 'ListItem') {
						throw new Error('Only <List.Item/>s can be placed inside a <List/> (and remove any whitespace).');
					}

					return _react2.default.cloneElement(item, {
						key: i,
						index: i,
						itemRef: _this2.isFocusableItem(item) ? _this2.storeItemRef : undefined,
						role: role === 'listbox' ? 'option' : item.props.role,
						focus: _this2.focusItem,
						focused: (expandable || isFocused) && focusedItemIndex === i,
						disabled: disabled || item.props.disabled,
						tabIndex: tabbable && (focusedItemIndex === undefined ? i === 0 : i === focusedItemIndex) ? 0 : -1,
						createButton: createButtons,
						isInputInProgress: _this2.isInputInProgress,
						onInputSpacebar: _this2.onInputSpacebar,
						onItemFocus: _this2.onItemFocus,
						onItemBlur: _this2.onBlur,
						onSelectItem: onChange || onSelectItem,
						hasOnSelectItem: hasOnChange,
						selectedItemValue: value,
						highlightSelectedItem: (onChange || onSelectItem) && highlightSelectedItem
					});
				})
			);
		}
	}]);

	return List;
}(PureComponent), _class.propTypes = {
	// (optional) HTML `id` attribute.
	// Can be used for WAI-ARIA stuff.
	// Example: `<input role="combobox"/>` with `aria-owns={listId}`.
	id: _propTypes2.default.string,

	value: _propTypes2.default.any,
	onChange: _propTypes2.default.func,

	// If a `<List/>` has `onChange` then it wraps `<List.Item/>`s with `<button/>`s.
	// The `onChange` added by `<ExpandableList/>` overrides the original `onChange`.
	// If there was no `onChange` — there will be one.
	// So to retain that info `hasOnChange` property is used as a workaround.
	// `undefined` means "ignore this property".
	hasOnChange: _propTypes2.default.bool,

	// If `items` property is supplied then it's used to
	// detect "on items changed" event in `getDerivedStateFromProps`.
	// It seems to be the only usage of the `items` property.
	items: _propTypes2.default.arrayOf(_propTypes2.default.object),

	// Legacy method, use `onChange` instead.
	onSelectItem: _propTypes2.default.func,
	highlightSelectedItem: _propTypes2.default.bool.isRequired,

	onFocusIn: _propTypes2.default.func,
	onFocusItem: _propTypes2.default.func,
	onKeyDown: _propTypes2.default.func,

	// ARIA `role` attribute.
	role: _propTypes2.default.string,

	// If a `<List/>` is `expandable`
	// then it won't be `.rrui__list:not(.rrui__list--focus)`.
	// `.rrui__list:not(.rrui__list--focus)` is only for standalone lists.
	expandable: _propTypes2.default.bool,

	tabbable: _propTypes2.default.bool.isRequired,
	shouldFocus: _propTypes2.default.bool.isRequired,
	highlightFirstItem: _propTypes2.default.bool.isRequired,
	createButtons: _propTypes2.default.bool.isRequired,

	// For select options list keyboard navigation via typing.
	resetInputTimeout: _propTypes2.default.number.isRequired
}, _class.defaultProps = {
	tabbable: true,
	shouldFocus: true,
	highlightFirstItem: false,
	createButtons: true,
	highlightSelectedItem: true,
	resetInputTimeout: 1000
}, _temp2);
exports.default = List;
var ListItem = exports.ListItem = (_temp4 = _class2 = function (_React$Component) {
	_inherits(ListItem, _React$Component);

	function ListItem() {
		var _ref2;

		var _temp3, _this3, _ret2;

		_classCallCheck(this, ListItem);

		for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
			args[_key2] = arguments[_key2];
		}

		return _ret2 = (_temp3 = (_this3 = _possibleConstructorReturn(this, (_ref2 = ListItem.__proto__ || Object.getPrototypeOf(ListItem)).call.apply(_ref2, [this].concat(args))), _this3), _this3.onButtonKeyDown = function (event) {
			var _this3$props = _this3.props,
			    isInputInProgress = _this3$props.isInputInProgress,
			    onInputSpacebar = _this3$props.onInputSpacebar;


			if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
				return;
			}

			switch (event.keyCode) {
				// "Spacebar".
				case 32:
					// If the user is currently typing.
					if (isInputInProgress()) {
						// Don't press the option button.
						event.preventDefault();
						// Append space character.
						onInputSpacebar();
					}
			}
		}, _this3.onMouseDown = function (event) {
			var _this3$props2 = _this3.props,
			    value = _this3$props2.value,
			    index = _this3$props2.index,
			    focus = _this3$props2.focus,
			    children = _this3$props2.children;

			// If `<List.Item/>` child element gets wrapped in a `<button/>`
			// then call `onMouseDown` defined on the `<List.Item/>`.
			// If `<List.Item/>` child element doesn't get wrapped in a `<button/>`
			// then manually call `onMouseDown` defined on the `<List.Item/>` child element
			// because `onMouseDown` gets overridden for `<List.Item/>` child element.

			var onMouseDown = _this3.shouldCreateButton() ? _this3.props.onMouseDown : children.props.onMouseDown;

			// Without this Safari (both mobile and desktop)
			// won't select any item in an expanded list
			// because it will collapse the list immediately
			// on `mouseDown` due to `blur` event being fired.
			event.preventDefault();

			if (_this3.isSelectable()) {
				focus(index);
			}

			if (onMouseDown) {
				onMouseDown(event);
			}
		}, _this3.onFocus = function (event) {
			var _this3$props3 = _this3.props,
			    focus = _this3$props3.focus,
			    index = _this3$props3.index,
			    onItemFocus = _this3$props3.onItemFocus,
			    children = _this3$props3.children;

			// If `<List.Item/>` child element gets wrapped in a `<button/>`
			// then call `onFocus` defined on the `<List.Item/>`.
			// If `<List.Item/>` child element doesn't get wrapped in a `<button/>`
			// then manually call `onFocus` defined on the `<List.Item/>` child element
			// because `onFocus` gets overridden for `<List.Item/>` child element.

			var onFocus = _this3.shouldCreateButton() ? _this3.props.onFocus : children.props.onFocus;

			if (_this3.isSelectable()) {
				focus(index);
			}

			if (onFocus) {
				onFocus(event);
			}

			if (onItemFocus) {
				onItemFocus(event);
			}
		}, _this3.onBlur = function (event) {
			var _this3$props4 = _this3.props,
			    onItemBlur = _this3$props4.onItemBlur,
			    children = _this3$props4.children;

			// If `<List.Item/>` child element gets wrapped in a `<button/>`
			// then call `onBlur` defined on the `<List.Item/>`.
			// If `<List.Item/>` child element doesn't get wrapped in a `<button/>`
			// then manually call `onFocus` defined on the `<List.Item/>` child element
			// because `onBlur` gets overridden for `<List.Item/>` child element.

			var onBlur = _this3.shouldCreateButton() ? _this3.props.onBlur : children.props.onBlur;

			if (onBlur) {
				onBlur(event);
			}

			if (onItemBlur) {
				onItemBlur(event);
			}
		}, _this3.onClick = function (event) {
			var _this3$props5 = _this3.props,
			    onClick = _this3$props5.onClick,
			    onSelect = _this3$props5.onSelect,
			    onSelectItem = _this3$props5.onSelectItem,
			    index = _this3$props5.index,
			    value = _this3$props5.value,
			    children = _this3$props5.children;

			// If `<List.Item/>` child element gets wrapped in a `<button/>`
			// then call `onClick` defined on the `<List.Item/>`.
			// If `<List.Item/>` child element doesn't get wrapped in a `<button/>`
			// then manually call `onClick` defined on the `<List.Item/>` child element
			// because `onClick` gets overridden for `<List.Item/>` child element,
			// and also call `onClick` defined on the `<List.Item/>` (if any).

			if (onClick) {
				onClick(event);
			}

			if (!_this3.shouldCreateButton()) {
				// Since `onClick` gets overridden
				// for `<List.Item/>` child element
				// call its original `onClick` manually here.
				if (children.props.onClick) {
					children.props.onClick(event);
				}
			}

			if (_this3.isSelectable()) {
				if (onSelect) {
					onSelect(value, index);
				}
				if (onSelectItem) {
					onSelectItem(value, index);
				}
			}
		}, _this3.focus = function () {
			var children = _this3.props.children;

			(0, _focus.focus)(_react2.default.Children.toArray(children)[0]);
		}, _this3.storeRef = function (ref) {
			var _this3$props6 = _this3.props,
			    itemRef = _this3$props6.itemRef,
			    index = _this3$props6.index;


			if (itemRef) {
				itemRef(ref, index);
			}
		}, _temp3), _possibleConstructorReturn(_this3, _ret2);
	}

	_createClass(ListItem, [{
		key: 'isSelectable',
		value: function isSelectable() {
			return isSelectableItem(this);
		}

		// Perhaps this is called by `focus()` utility function.
		// Something like: `focus(this.itemRefs[i])`.

	}, {
		key: 'shouldCreateButton',
		value: function shouldCreateButton() {
			var _props3 = this.props,
			    onClick = _props3.onClick,
			    onSelect = _props3.onSelect,
			    onSelectItem = _props3.onSelectItem,
			    hasOnSelectItem = _props3.hasOnSelectItem,
			    createButton = _props3.createButton,
			    shouldCreateButton = _props3.shouldCreateButton;


			return this.isSelectable() && (onClick || onSelect || onSelectItem && (hasOnSelectItem === undefined ? true : hasOnSelectItem) && (createButton || shouldCreateButton));
		}
	}, {
		key: 'render',
		value: function render() {
			var _props4 = this.props,
			    id = _props4.id,
			    value = _props4.value,
			    icon = _props4.icon,
			    role = _props4.role,
			    focused = _props4.focused,
			    disabled = _props4.disabled,
			    className = _props4.className,
			    tabIndex = _props4.tabIndex,
			    highlightSelectedItem = _props4.highlightSelectedItem,
			    selectedItemValue = _props4.selectedItemValue,
			    children = _props4.children;

			// Throws an error for some weird reason.
			// React.Children.only(children)

			if (_react2.default.Children.count(children) !== 1) {
				throw new Error('Each <List.Item/> must have a single child (and remove any whitespace).');
			}

			var isSelected = this.shouldCreateButton() && value === selectedItemValue;

			var properties = {
				ref: this.storeRef,
				onMouseDown: this.onMouseDown,
				onClick: this.onClick,
				onFocus: this.onFocus,
				onBlur: this.onBlur,
				className: (0, _classnames2.default)(className, 'rrui__list__item', {
					/* `--focused` modifier is deprecated, use `--focus` instead. */
					'rrui__list__item--focused': focused,
					'rrui__list__item--focus': focused,
					'rrui__list__item--selected': isSelected && highlightSelectedItem,
					'rrui__list__item--disabled': disabled,
					'rrui__list__item--divider': isDivider(children)
				})
			};

			if (id !== undefined) {
				properties.id = id;
			}

			if (tabIndex !== undefined) {
				properties.tabIndex = tabIndex;
			}

			var ItemComponent = void 0;
			var itemChildren = void 0;
			var label = void 0;

			if (this.shouldCreateButton()) {
				ItemComponent = 'button';
				label = getItemLabel(this);
				properties.type = 'button';
				properties.role = role;
				properties['aria-selected'] = isSelected;
				properties['aria-label'] = this.props.label || (typeof children !== 'string' && children && children.props ? children.props['aria-label'] : undefined);
				properties.disabled = disabled;
				properties.onKeyDown = this.onButtonKeyDown;
				properties.className = (0, _classnames2.default)(properties.className, 'rrui__button-reset', 'rrui__outline', 'rrui__list__item--button');

				// Replace `itemChildren` array with `<React.Fragment/>`
				// in some future when React >= 16.2.0 is common.
				//
				// <React.Fragment>
				// 	{/* Icon. */}
				// 	{ icon &&
				// 		<div className="rrui__list__item-icon">
				// 			{ React.createElement(icon, { value, label }) }
				// 		</div>
				// 	}
				//
				// 	{/* Label (or content). */}
				// 	{ children }
				// </React.Fragment>

				// Label (or content).
				itemChildren = _react2.default.Children.toArray(children);

				// Icon.
				if (icon) {
					itemChildren.unshift(_react2.default.createElement(
						'span',
						{ key: 'icon', 'aria-hidden': true, className: 'rrui__list__item-icon' },
						_react2.default.createElement(icon, { value: value, label: label })
					));
				}
			} else {
				// Don't overwrite `className` already defined on the `children`.
				properties.className = (0, _classnames2.default)(properties.className, children.props && children.props.className);
			}

			return _react2.default.createElement(
				'li',
				{
					role: this.shouldCreateButton() || isDivider(children) ? 'presentation' : role,
					'aria-selected': this.shouldCreateButton() ? undefined : role && role !== 'presentation' ? isSelected : undefined,
					'aria-label': this.shouldCreateButton() ? undefined : label,
					className: 'rrui__list__list-item' },
				ItemComponent && _react2.default.createElement(ItemComponent, properties, itemChildren),
				!ItemComponent && _react2.default.cloneElement(children, properties)
			);
		}
	}]);

	return ListItem;
}(_react2.default.Component), _class2.propTypes = {
	// (optional) HTML `id` attribute.
	// Can be used for WAI-ARIA stuff.
	// Example: `<input role="combobox"/>` with `aria-activedescendant={focusedListItemId}`.
	id: _propTypes2.default.string,

	value: _propTypes2.default.any,
	index: _propTypes2.default.number,
	focused: _propTypes2.default.bool,
	onClick: _propTypes2.default.func,
	// `onSelect` is deprecated, use `onClick` instead.
	onSelect: _propTypes2.default.func,
	onSelectItem: _propTypes2.default.func,
	// If a `<List/>` has `onChange` then it wraps `<List.Item/>`s with `<button/>`s.
	// The `onChange` added by `<ExpandableList/>` overrides the original `onChange`.
	// If there was no `onChange` — there will be one.
	// So to retain that info `hasOnChange` property is used as a workaround.
	// `undefined` means "ignore this property".
	hasOnSelectItem: _propTypes2.default.bool,
	selectedItemValue: _propTypes2.default.any,
	highlightSelectedItem: _propTypes2.default.bool,
	createButton: _propTypes2.default.bool,
	// Deprecated. Use `createButton` instead.
	shouldCreateButton: _propTypes2.default.bool,
	// The button won't be pressed on "Space" key
	// if the user is currently typing.
	isInputInProgress: _propTypes2.default.func,
	onInputSpacebar: _propTypes2.default.func
}, _temp4);

// Workaround for `react-hot-loader`.
// https://github.com/gaearon/react-hot-loader#checking-element-types

ListItem.displayName = 'ListItem';

List.Item = ListItem;

function haveItemsChanged(props, prevProps) {
	var items = _react2.default.Children.toArray(props.children);
	var prevItems = _react2.default.Children.toArray(prevProps.children);

	if (items.length !== prevItems.length) {
		return true;
	}

	var i = 0;
	while (i < items.length) {
		if (items[i].props.value !== prevItems[i].props.value) {
			return true;
		}
		i++;
	}

	return false;
}

function findItemIndexByValue(value, children) {
	var items = _react2.default.Children.toArray(children);

	var i = 0;
	for (var _iterator = items, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
		var _ref3;

		if (_isArray) {
			if (_i >= _iterator.length) break;
			_ref3 = _iterator[_i++];
		} else {
			_i = _iterator.next();
			if (_i.done) break;
			_ref3 = _i.value;
		}

		var item = _ref3;

		if (isSelectableItem(item) && item.props.value === value) {
			return i;
		}
		i++;
	}
}

function findItemIndexByLabel(value, children) {
	var items = _react2.default.Children.toArray(children);

	var i = 0;
	for (var _iterator2 = items, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
		var _ref4;

		if (_isArray2) {
			if (_i2 >= _iterator2.length) break;
			_ref4 = _iterator2[_i2++];
		} else {
			_i2 = _iterator2.next();
			if (_i2.done) break;
			_ref4 = _i2.value;
		}

		var item = _ref4;

		if (isSelectableItem(item)) {
			var itemLabel = getItemLabel(item);
			if (itemLabel && itemLabel.toLowerCase().indexOf(value.toLowerCase()) === 0) {
				return i;
			}
		}
		i++;
	}
}

function getItemLabel(item) {
	return item.props.label || (typeof item.props.children === 'string' ? item.props.children : undefined);
}

function isSelectableItem(item) {
	return item.props.children && !isDivider(item.props.children);
}

function isDivider(element) {
	// Workaround for `react-hot-loader`.
	// https://github.com/gaearon/react-hot-loader#checking-element-types
	return element.type && element.type.displayName === 'Divider';
}
//# sourceMappingURL=List.js.map