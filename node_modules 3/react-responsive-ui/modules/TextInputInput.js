'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp2;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _reactCreateRef = require('react-create-ref');

var _reactCreateRef2 = _interopRequireDefault(_reactCreateRef);

var _grid = require('./utility/grid');

var _dom = require('./utility/dom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = _react2.default.PureComponent || _react2.default.Component;

var TextInput = (_temp2 = _class = function (_PureComponent) {
	_inherits(TextInput, _PureComponent);

	function TextInput() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, TextInput);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = TextInput.__proto__ || Object.getPrototypeOf(TextInput)).call.apply(_ref, [this].concat(args))), _this), _this.initAutoresizeAttempts = 0, _this.currentHeight = 0, _this.hiddenTextArea = (0, _reactCreateRef2.default)(), _this.initAutoresize = function () {
			if (!_this._isMounted) {
				return;
			}
			_this.initAutoresizeAttempts++;
			_this.getMeasurements();
			if (_this.haveStylesLoaded()) {
				_this.autoresize();
			}
			// Even if padding on <textarea/> has been set
			// it's still possible that `font-size` hasn't been set yet.
			// Or it could be another padding in a subsequent stylesheet.
			// So keep re-initializing <textarea/>, say, for a second.
			if (_this.initAutoresizeAttempts <= 5) {
				setTimeout(_this.initAutoresize, 200);
			}
		}, _this.autoresize = function (event) {
			// const { rowsMax } = this.props

			// Guarding for **broken** shallow rendering method that call componentDidMount
			// but doesn't handle refs correctly.
			// To remove once the shallow rendering has been fixed.
			if (!_this.hiddenTextArea.current) {
				return;
			}

			// const lineHeight = this.hiddenTextAreaSingleLine.current.scrollHeight - this.verticalPadding
			var height = _this.hiddenTextArea.current.scrollHeight;

			// Guarding for jsdom, where scrollHeight isn't present.
			// See https://github.com/tmpvar/jsdom/issues/1013
			if (height === undefined) {
				return;
			}

			// It would have to first subtract `paddingTop` and `paddingBottom`,
			// then it would calculate `rowsMax * lineHeight` and
			// then it would re-add `paddingTop` and `paddingBottom`.
			// height = Math.min(rowsMax * lineHeight + this.verticalPadding, height)

			// `.scrollHeight` doesn't include borders.
			// `.style.height` does include borders.
			height += _this.bordersHeight;

			// if (height <= this.minHeight) {
			// 	height = this.minHeight
			// }
			// For some weird reason Chrome on Windows 10
			// requires an extra pixel been added
			// to avoid showing vertical scrollbar.
			// (Oct 24th, 2018)
			// else {
			height += 1;
			// }

			// "Need a large enough different to update the height.
			//  This prevents infinite rendering loop."
			// It's unclear what loop they're talking about.
			if (Math.abs(_this.currentHeight - height) > 1) {
				_this.currentHeight = height;
				// `.style.height` includes borders.
				_this.input.style.height = height + 'px';
			}
		}, _this.onWindowResize = (0, _throttle2.default)(function (event) {
			return _this.autoresize();
		}, 100), _this.onChange = function (event) {
			// Extract `value` from the argument
			// of this `onChange` listener
			// (for convenience)

			var value = event;

			if (event.target !== undefined) {
				value = event.target.value;
			}

			// Call the parent `onChange` handler
			// with the `value` as an argument
			// (for convenience)

			var onChange = _this.props.onChange;

			// Call `onChange` only if `value` did actually change

			if (value !== _this.props.value) {
				onChange(value);
			}
		}, _this.onKeyDown = function (event) {
			var onKeyDown = _this.props.onKeyDown;


			if (onKeyDown) {
				onKeyDown(event);
			}

			if (event.defaultPrevented) {
				return;
			}

			if ((0, _dom.submitFormOnCtrlEnter)(event, _this.input)) {
				return;
			}
		}, _this.storeInputNode = function (node) {
			var inputRef = _this.props.inputRef;


			if (inputRef) {
				inputRef(node);
			}

			_this.input = node;
		}, _this.focus = function () {
			return _this.input.focus();
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(TextInput, [{
		key: 'componentDidMount',

		// hiddenTextAreaSingleLine = createRef()

		// Client side rendering, javascript is enabled
		value: function componentDidMount() {
			var _props = this.props,
			    multiline = _props.multiline,
			    autoresize = _props.autoresize,
			    value = _props.value;


			this._isMounted = true;

			// Doing `this.measure()` here now
			// because `<textarea/>` should autoresize
			// in case its `value` is set up front.
			// // Not doing `this.measure()` here because
			// // that resulted in weird `<textarea/>` height mismatch.
			// // Measuring the height of `<textarea/>` during
			// // the first `this.measurements()` call instead.

			if (multiline && autoresize) {
				this.initAutoresize();
			}

			if (multiline && autoresize) {
				window.addEventListener('resize', this.onWindowResize);
			}
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			var _props2 = this.props,
			    multiline = _props2.multiline,
			    autoresize = _props2.autoresize;


			this._isMounted = false;

			if (multiline && autoresize) {
				window.removeEventListener('resize', this.onWindowResize);
			}
		}
	}, {
		key: 'componentDidUpdate',
		value: function componentDidUpdate() {
			var autoresize = this.props.autoresize;


			if (autoresize) {
				this.autoresize();
			}
		}

		// Even if padding on <textarea/> has been set
		// it's still possible that `font-size` hasn't been set yet.
		// (it happened in a project)
		// So this function doesn't guarantee anything.

	}, {
		key: 'haveStylesLoaded',
		value: function haveStylesLoaded() {
			// The default <textarea/> top/bottom padding in Chrome on Windows is 2px.
			return this.verticalPadding > 2 * 2;
		}

		// `height` works incorrectly in some weird cases.
		// For example, when `<textarea/>` is hidden when mounted
		// or when there's no stylesheet loaded yet.
		// For example, when stylesheets are included "dynamically"
		// like Webpack's `style-loader` does (is used in development mode,
		// or when using "code splitting" when "chunks" are `import()`ed dynamically).
		//
		// https://stackoverflow.com/questions/39400038/how-to-ensure-that-hot-css-loads-before-js-in-webpack-dev-server
		// https://github.com/webpack-contrib/style-loader/issues/269
		//
		// An alternative solution would be:
		//
		// this.input.minHeight = 0
		// this.input.minHeight = this.input.scrollHeight + this.bordersHeight
		//
		// or:
		//
		// this.input.minHeight = this.hiddenTextArea.current.scrollHeight + this.bordersHeight
		//
		// which wouldn't ever undersize the <textarea/>
		// but it would oversize it due to the incorrect
		// <textarea/> width before styles are loaded.
		//

	}, {
		key: 'getMeasurements',
		value: function getMeasurements() {
			var style = getComputedStyle(this.input);

			// // Measurements can be in `em`s/`rem`s/`pt`s which can give fractional pixel sizes.
			// // `style.height` includes borders.
			// this.currentHeight = Math.ceil(parseFloat(style.height))
			// this.minHeight = this.currentHeight

			// Get vertical padding.
			// Measurements can be in `em`s/`rem`s/`pt`s which can give fractional pixel sizes.
			this.verticalPadding = Math.ceil(parseFloat(style.paddingTop)) + Math.ceil(parseFloat(style.paddingBottom));

			// Top and bottom borders are extra height,
			// because `.scrollHeight` doesn't include borders.
			// Measurements can be in `em`s/`rem`s/`pt`s which can give fractional pixel sizes.
			this.bordersHeight = Math.ceil(parseFloat(style.borderTopWidth)) + Math.ceil(parseFloat(style.borderBottomWidth));
		}

		// Copy-pasted from Material UI on Oct 24th, 2018.
		// https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/InputBase/Textarea.js
		//


		// The underlying `input` component
		// can pass both `event`s and `value`s
		// to this parent `onChange` listener.

	}, {
		key: 'render',
		value: function render() {
			var _props3 = this.props,
			    id = _props3.id,
			    value = _props3.value,
			    multiline = _props3.multiline,
			    inputComponent = _props3.inputComponent,
			    focus = _props3.focus,
			    onChange = _props3.onChange,
			    disabled = _props3.disabled,
			    label = _props3.label,
			    placeholder = _props3.placeholder,
			    type = _props3.type,
			    autoresize = _props3.autoresize,
			    indicateInvalid = _props3.indicateInvalid,
			    error = _props3.error,
			    className = _props3.className,
			    inputRef = _props3.inputRef,
			    containerRef = _props3.containerRef,
			    floatingLabel = _props3.floatingLabel,
			    required = _props3.required,
			    children = _props3.children,
			    rest = _objectWithoutProperties(_props3, ['id', 'value', 'multiline', 'inputComponent', 'focus', 'onChange', 'disabled', 'label', 'placeholder', 'type', 'autoresize', 'indicateInvalid', 'error', 'className', 'inputRef', 'containerRef', 'floatingLabel', 'required', 'children']);

			var inputStyle = this.props.inputStyle;


			if (multiline && autoresize) {
				inputStyle = _extends({
					resize: 'none'
				}, inputStyle);
			}

			var properties = _extends({}, rest, {
				id: id,
				ref: this.storeInputNode,
				value: isEmptyValue(value) ? '' : value,
				disabled: disabled,
				'aria-label': rest['aria-label'] || (id && label ? undefined : label),
				'aria-required': rest['aria-required'] || (required ? true : undefined),
				'aria-invalid': rest['aria-invalid'] || (error && indicateInvalid ? true : undefined),
				placeholder: placeholder,
				onChange: this.onChange,
				onKeyDown: this.onKeyDown,
				className: (0, _classnames2.default)(
				// `<TextInput/>` has `border-color` to indicate its `:focus` state.
				// Therefore the `outline` can be safely removed.
				'rrui__outline', 'rrui__input-element', 'rrui__input-field', {
					// CSS selector performance optimization
					'rrui__input-field--invalid': indicateInvalid && error,
					'rrui__input-field--disabled': disabled,
					'rrui__input-field--multiline': multiline
				}, className),
				style: inputStyle,
				autoFocus: focus

				// In case of `multiline` set to `true`
				// this is gonna be a `<textarea/>`
			});if (multiline) {
				if (autoresize) {
					return [
					// <textarea
					// 	key="textarea-measurement-single-line"
					// 	ref={this.hiddenTextAreaSingleLine}
					// 	rows="1"
					// 	readOnly
					// 	aria-hidden="true"
					// 	value=""
					// 	tabIndex={-1}
					// 	className={properties.className}
					// 	style={this.props.inputStyle ? { ...inputStyle, ...HIDDEN_TEXTAREA_STYLE } : HIDDEN_TEXTAREA_STYLE}/>,

					_react2.default.createElement('textarea', {
						key: 'textarea-measurement',
						ref: this.hiddenTextArea,
						readOnly: true,
						'aria-hidden': true,
						value: properties.value,
						rows: properties.rows,
						tabIndex: -1,
						className: properties.className,
						style: this.props.inputStyle ? _extends({}, inputStyle, HIDDEN_TEXTAREA_STYLE) : HIDDEN_TEXTAREA_STYLE }), _react2.default.createElement('textarea', _extends({
						key: 'textarea'
					}, properties))];
				}

				return _react2.default.createElement('textarea', _extends({ key: 'textarea' }, properties));
			}

			// Add `<input/>` `type` property.
			if (inputComponent === 'input') {
				properties.type = type || 'text';
			}

			return _react2.default.createElement(inputComponent, properties);
		}
	}]);

	return TextInput;
}(PureComponent), _class.propTypes = {
	// (optional) HTML `id` attribute.
	id: _propTypes2.default.string,

	// `<input type/>` attribute.
	type: _propTypes2.default.string,

	// Whether `<textarea/>` should autoresize itself
	// (is `true` by default)
	autoresize: _propTypes2.default.bool.isRequired,

	// In order for this to work properly
	// `<textarea/>` vertical padding should be `0`
	// and instead the padding should be defined on `<textarea/>` parent `<div/>`
	// like it's done in Material UI.
	// Otherwise it won't look pretty and the line of text near the top border
	// will be partially visible resulting in weird UX.
	// If `<textarea/>` vertical padding was `0`
	// the line of text near the top border wouldn't be visible.
	// // The maximum number of rows <textarea/> grows up to.
	// rowsMax          : PropTypes.number.isRequired,

	// Set to `false` to prevent the `<label/>` from floating
	floatingLabel: _propTypes2.default.bool.isRequired,

	// A custom input component.
	// (is `<input/>` by default)
	inputComponent: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired
}, _class.defaultProps = {
	// `<textarea/>` should autoresize itself
	autoresize: true,

	// Set to `false` to prevent the `<label/>` from floating
	floatingLabel: true,

	// A custom input component.
	// (is `<input/>` by default)
	inputComponent: 'input'

	// // The maximum number of rows <textarea/> grows up to.
	// rowsMax : 12
}, _temp2);

// https://github.com/mui-org/material-ui/blob/master/packages/material-ui/src/InputBase/Textarea.js

exports.default = TextInput;
var HIDDEN_TEXTAREA_STYLE = {
	// Overflow also needed to here to remove the extra row
	// added to `<textarea/>`s in Firefox.
	overflow: 'hidden',
	// Visibility needed to hide the extra `<textarea/>` on iPads.
	visibility: 'hidden',
	position: 'absolute',
	height: 'auto',
	// Don't know why is it here.
	whiteSpace: 'pre-wrap'
};

function isEmptyValue(value) {
	return value === '' || value === undefined || value === null;
}
//# sourceMappingURL=TextInputInput.js.map