{"version":3,"sources":["../source/format.js"],"names":["formatNumber","normalizeArguments","arguments","input","format","options","metadata","args","Array","prototype","slice","call","arg_1","arg_2","arg_3","arg_4","arg_5","defaultCountry","extended","Error","is_object","TypeError","_"],"mappings":";;;;;;;;;;kBAGwBA,Y;;AAHxB;;;;AACA;;;;;;AAEe,SAASA,YAAT,GACf;AAAA,2BAQGC,mBAAmBC,SAAnB,CARH;AAAA,KAGEC,KAHF,uBAGEA,KAHF;AAAA,KAIEC,MAJF,uBAIEA,MAJF;AAAA,KAKEC,OALF,uBAKEA,OALF;AAAA,KAMEC,QANF,uBAMEA,QANF;;AAUC,QAAO,uBAAcH,KAAd,EAAqBC,MAArB,EAA6BC,OAA7B,EAAsCC,QAAtC,CAAP;AACA;;AAED;AACA,SAASL,kBAAT,CAA4BM,IAA5B,EACA;AAAA,6BAC6CC,MAAMC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BJ,IAA3B,CAD7C;AAAA;AAAA,KACQK,KADR;AAAA,KACeC,KADf;AAAA,KACsBC,KADtB;AAAA,KAC6BC,KAD7B;AAAA,KACoCC,KADpC;;AAGC,KAAIb,cAAJ;AACA,KAAIC,eAAJ;AACA,KAAIC,gBAAJ;AACA,KAAIC,iBAAJ;;AAEA;;AAEA;AACA;AACA,KAAI,OAAOM,KAAP,KAAiB,QAArB,EACA;AACC;AACA;AACA,MAAI,OAAOE,KAAP,KAAiB,QAArB,EACA;AACCV,YAASU,KAAT;;AAEA,OAAIE,KAAJ,EACA;AACCX,cAAWU,KAAX;AACAT,eAAWU,KAAX;AACA,IAJD,MAMA;AACCV,eAAWS,KAAX;AACA;;AAEDZ,WAAQ,sBAAMS,KAAN,EAAa,EAAEK,gBAAgBJ,KAAlB,EAAyBK,UAAU,IAAnC,EAAb,EAAwDZ,QAAxD,CAAR;AACA;AACD;AACA;AAjBA,OAmBA;AACC,QAAI,OAAOO,KAAP,KAAiB,QAArB,EACA;AACC,WAAM,IAAIM,KAAJ,CAAU,gEAAV,CAAN;AACA;;AAEDf,aAASS,KAAT;;AAEA,QAAIE,KAAJ,EACA;AACCV,eAAWS,KAAX;AACAR,gBAAWS,KAAX;AACA,KAJD,MAMA;AACCT,gBAAWQ,KAAX;AACA;;AAEDX,YAAQ,sBAAMS,KAAN,EAAa,EAAEM,UAAU,IAAZ,EAAb,EAAiCZ,QAAjC,CAAR;AACA;AACD;AACD;AACA;AA7CA,MA8CK,IAAIc,UAAUR,KAAV,CAAJ,EACL;AACCT,WAASS,KAAT;AACAR,YAASS,KAAT;;AAEA,OAAIE,KAAJ,EACA;AACCV,cAAWS,KAAX;AACAR,eAAWS,KAAX;AACA,IAJD,MAMA;AACCT,eAAWQ,KAAX;AACA;AACD,GAdI,MAeA,MAAM,IAAIO,SAAJ,CAAc,oFAAd,CAAN;;AAEL;AACA,KAAIjB,WAAW,eAAf,EAAgC;AAC/BA,WAAS,eAAT;AACA,EAFD,MAEO,IAAIA,WAAW,UAAf,EAA2B;AACjCA,WAAS,UAAT;AACA;;AAED,QAAO;AACND,cADM;AAENC,gBAFM;AAGNC,kBAHM;AAINC;AAJM,EAAP;AAMA;;AAED;AACA;AACA;AACA,IAAMc,YAAY,SAAZA,SAAY;AAAA,QAAK,QAAOE,CAAP,yCAAOA,CAAP,OAAa,QAAlB;AAAA,CAAlB","file":"format.js","sourcesContent":["import _formatNumber from './format_'\r\nimport parse from './parse_'\r\n\r\nexport default function formatNumber()\r\n{\r\n\tconst\r\n\t{\r\n\t\tinput,\r\n\t\tformat,\r\n\t\toptions,\r\n\t\tmetadata\r\n\t}\r\n\t= normalizeArguments(arguments)\r\n\r\n\treturn _formatNumber(input, format, options, metadata)\r\n}\r\n\r\n// Sort out arguments\r\nfunction normalizeArguments(args)\r\n{\r\n\tconst [arg_1, arg_2, arg_3, arg_4, arg_5] = Array.prototype.slice.call(args)\r\n\r\n\tlet input\r\n\tlet format\r\n\tlet options\r\n\tlet metadata\r\n\r\n\t// Sort out arguments.\r\n\r\n\t// If the phone number is passed as a string.\r\n\t// `format('8005553535', ...)`.\r\n\tif (typeof arg_1 === 'string')\r\n\t{\r\n\t\t// If country code is supplied.\r\n\t\t// `format('8005553535', 'RU', 'NATIONAL', [options], metadata)`.\r\n\t\tif (typeof arg_3 === 'string')\r\n\t\t{\r\n\t\t\tformat = arg_3\r\n\r\n\t\t\tif (arg_5)\r\n\t\t\t{\r\n\t\t\t\toptions  = arg_4\r\n\t\t\t\tmetadata = arg_5\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmetadata = arg_4\r\n\t\t\t}\r\n\r\n\t\t\tinput = parse(arg_1, { defaultCountry: arg_2, extended: true }, metadata)\r\n\t\t}\r\n\t\t// Just an international phone number is supplied\r\n\t\t// `format('+78005553535', 'NATIONAL', [options], metadata)`.\r\n\t\telse\r\n\t\t{\r\n\t\t\tif (typeof arg_2 !== 'string')\r\n\t\t\t{\r\n\t\t\t\tthrow new Error('`format` argument not passed to `formatNumber(number, format)`')\r\n\t\t\t}\r\n\r\n\t\t\tformat = arg_2\r\n\r\n\t\t\tif (arg_4)\r\n\t\t\t{\r\n\t\t\t\toptions  = arg_3\r\n\t\t\t\tmetadata = arg_4\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tmetadata = arg_3\r\n\t\t\t}\r\n\r\n\t\t\tinput = parse(arg_1, { extended: true }, metadata)\r\n\t\t}\r\n\t}\r\n\t// If the phone number is passed as a parsed number object.\r\n\t// `format({ phone: '8005553535', country: 'RU' }, 'NATIONAL', [options], metadata)`.\r\n\telse if (is_object(arg_1))\r\n\t{\r\n\t\tinput  = arg_1\r\n\t\tformat = arg_2\r\n\r\n\t\tif (arg_4)\r\n\t\t{\r\n\t\t\toptions  = arg_3\r\n\t\t\tmetadata = arg_4\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tmetadata = arg_3\r\n\t\t}\r\n\t}\r\n\telse throw new TypeError('A phone number must either be a string or an object of shape { phone, [country] }.')\r\n\r\n\t// Legacy lowercase formats.\r\n\tif (format === 'International') {\r\n\t\tformat = 'INTERNATIONAL'\r\n\t} else if (format === 'National') {\r\n\t\tformat = 'NATIONAL'\r\n\t}\r\n\r\n\treturn {\r\n\t\tinput,\r\n\t\tformat,\r\n\t\toptions,\r\n\t\tmetadata\r\n\t}\r\n}\r\n\r\n// Babel transforms `typeof` into some \"branches\"\r\n// so istanbul will show this as \"branch not covered\".\r\n/* istanbul ignore next */\r\nconst is_object = _ => typeof _ === 'object'"]}