{"version":3,"sources":["../source/AsYouType.js"],"names":["strip_dangling_braces","cut_stripping_dangling_braces","close_dangling_braces","count_occurences","repeat","DUMMY_DIGIT","LONGEST_NATIONAL_PHONE_NUMBER_LENGTH","LONGEST_DUMMY_PHONE_NUMBER","DIGIT_PLACEHOLDER","DIGIT_PLACEHOLDER_MATCHER","RegExp","SUPPORT_LEGACY_FORMATTING_PATTERNS","CREATE_CHARACTER_CLASS_PATTERN","CREATE_STANDALONE_DIGIT_PATTERN","ELIGIBLE_FORMAT_PATTERN","MIN_LEADING_DIGITS_LENGTH","VALID_INCOMPLETE_PHONE_NUMBER","VALID_INCOMPLETE_PHONE_NUMBER_PATTERN","AsYouType","defaultCountry","metadata","options","hasCountry","reset","text","extracted_number","indexOf","test","currentOutput","processInput","input","parsedInput","resetCountriness","slice","nationalNumber","isInternational","countryCallingCode","extractCountryCallingCode","initialize_phone_number_formats_for_this_country_calling_code","resetFormat","determineTheCountry","country","previous_national_prefix","nationalPrefix","extractNationalPrefix","matching_formats","undefined","format_as_non_formatted_number","match_formats_by_leading_digits","formatted_national_phone_number","formatNationalNumber","formatFullNumber","next_digits","national_number_formatted_with_previous_format","chosenFormat","formatNextNationalNumberDigits","formatted_number","attempt_to_format_complete_phone_number","chooseAnotherFormat","reformatNationalNumber","carrierCode","resetCountry","available_formats","template","partially_populated_template","last_match_position","formats","filter","format","internationalFormat","leading_digits","index_of_leading_digits_pattern","length","had_enough_leading_digits","shouldFormat","leading_digits_patterns_count","leadingDigitsPatterns","leading_digits_pattern_index","Math","min","leading_digits_pattern","matcher","pattern","isFormatApplicable","createFormattingTemplate","full_number","replace","formattedNationalNumber","number","chooseCountryByCountryCallingCode","selectedCountry","potential_national_number","possibleLengths","isPossibleNumber","nationalNumberPattern","validation_result","nationalPrefixIsMandatoryWhenFormatting","usesNationalPrefix","nationalPrefixIsOptionalWhenFormatting","getTemplateForNumberFormatPattern","number_pattern","dummy_phone_number_matching_format_pattern","match","number_format","getFormatFormat","strict_pattern","national_number_dummy_digits","digits","split","digit","search","nationalPrefixFormattingRule","phoneNumber","index","i","string","dangling_braces","push","pop","start","cleared_string","cut_before_index","cut_before","retained_template","opening_braces","closing_braces","symbol","count","character","times","result"],"mappings":"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","file":"AsYouType.js","sourcesContent":["// This is an enhanced port of Google Android `libphonenumber`'s\r\n// `asyoutypeformatter.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/blob/8d21a365061de2ba0675c878a710a7b24f74d2ae/javascript/i18n/phonenumbers/asyoutypeformatter.js\r\n//\r\n// Simplified: does not differentiate between \"local-only\" numbers\r\n// and \"internationally dialable\" numbers.\r\n// For example, doesn't include changes like this:\r\n// https://github.com/googlei18n/libphonenumber/commit/865da605da12b01053c4f053310bac7c5fbb7935\r\n\r\nimport Metadata from './metadata'\r\n\r\nimport PhoneNumber from './PhoneNumber'\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tVALID_PUNCTUATION,\r\n\tPLUS_CHARS\r\n} from './constants'\r\n\r\nimport { matchesEntirely } from './util'\r\n\r\nimport {\r\n\textractCountryCallingCode,\r\n\textract_formatted_phone_number,\r\n\tfind_country_code,\r\n\tstrip_national_prefix_and_carrier_code\r\n} from './parse_'\r\n\r\nimport {\r\n\tFIRST_GROUP_PATTERN,\r\n\tformat_national_number_using_format,\r\n\tchangeInternationalFormatStyle\r\n} from './format_'\r\n\r\nimport { checkNumberLengthForType } from './getNumberType_'\r\n\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber'\r\n\r\n// Used in phone number format template creation.\r\n// Could be any digit, I guess.\r\nconst DUMMY_DIGIT = '9'\r\n// I don't know why is it exactly `15`\r\nconst LONGEST_NATIONAL_PHONE_NUMBER_LENGTH = 15\r\n// Create a phone number consisting only of the digit 9 that matches the\r\n// `number_pattern` by applying the pattern to the \"longest phone number\" string.\r\nconst LONGEST_DUMMY_PHONE_NUMBER = repeat(DUMMY_DIGIT, LONGEST_NATIONAL_PHONE_NUMBER_LENGTH)\r\n\r\n// The digits that have not been entered yet will be represented by a \\u2008,\r\n// the punctuation space.\r\nexport const DIGIT_PLACEHOLDER = 'x' // '\\u2008' (punctuation space)\r\nconst DIGIT_PLACEHOLDER_MATCHER = new RegExp(DIGIT_PLACEHOLDER)\r\n\r\n// Deprecated: Google has removed some formatting pattern related code from their repo.\r\n// https://github.com/googlei18n/libphonenumber/commit/a395b4fef3caf57c4bc5f082e1152a4d2bd0ba4c\r\n// Because this library supports generating custom metadata\r\n// some users may still be using old metadata so the relevant\r\n// code seems to stay until some next major version update.\r\nconst SUPPORT_LEGACY_FORMATTING_PATTERNS = true\r\n\r\n// A pattern that is used to match character classes in regular expressions.\r\n// An example of a character class is \"[1-4]\".\r\nconst CREATE_CHARACTER_CLASS_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\[([^\\[\\]])*\\]/g)\r\n\r\n// Any digit in a regular expression that actually denotes a digit. For\r\n// example, in the regular expression \"80[0-2]\\d{6,10}\", the first 2 digits\r\n// (8 and 0) are standalone digits, but the rest are not.\r\n// Two look-aheads are needed because the number following \\\\d could be a\r\n// two-digit number, since the phone number can be as long as 15 digits.\r\nconst CREATE_STANDALONE_DIGIT_PATTERN = SUPPORT_LEGACY_FORMATTING_PATTERNS && (() => /\\d(?=[^,}][^,}])/g)\r\n\r\n// A pattern that is used to determine if a `format` is eligible\r\n// to be used by the \"as you type formatter\".\r\n// It is eligible when the `format` contains groups of the dollar sign\r\n// followed by a single digit, separated by valid phone number punctuation.\r\n// This prevents invalid punctuation (such as the star sign in Israeli star numbers)\r\n// getting into the output of the \"as you type formatter\".\r\nconst ELIGIBLE_FORMAT_PATTERN = new RegExp\r\n(\r\n\t'^' +\r\n\t'[' + VALID_PUNCTUATION + ']*' +\r\n\t'(\\\\$\\\\d[' + VALID_PUNCTUATION + ']*)+' +\r\n\t'$'\r\n)\r\n\r\n// This is the minimum length of the leading digits of a phone number\r\n// to guarantee the first \"leading digits pattern\" for a phone number format\r\n// to be preemptive.\r\nconst MIN_LEADING_DIGITS_LENGTH = 3\r\n\r\nconst VALID_INCOMPLETE_PHONE_NUMBER =\r\n\t'[' + PLUS_CHARS + ']{0,1}' +\r\n\t'[' +\r\n\t\tVALID_PUNCTUATION +\r\n\t\tVALID_DIGITS +\r\n\t']*'\r\n\r\nconst VALID_INCOMPLETE_PHONE_NUMBER_PATTERN = new RegExp('^' + VALID_INCOMPLETE_PHONE_NUMBER + '$', 'i')\r\n\r\nexport default class AsYouType\r\n{\r\n\t// Not setting `options` to a constructor argument\r\n\t// not to break backwards compatibility\r\n\t// for older versions of the library.\r\n\toptions = {}\r\n\r\n\t/**\r\n\t * @param {string?} [defaultCountry] - The default country used for parsing non-international phone numbers.\r\n\t * @param {Object} metadata\r\n\t */\r\n\tconstructor(defaultCountry, metadata)\r\n\t{\r\n\t\tthis.metadata = new Metadata(metadata)\r\n\r\n\t\tif (defaultCountry && this.metadata.hasCountry(defaultCountry)) {\r\n\t\t\tthis.defaultCountry = defaultCountry\r\n\t\t}\r\n\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\tinput(text)\r\n\t{\r\n\t\t// Parse input\r\n\r\n\t\tlet extracted_number = extract_formatted_phone_number(text) || ''\r\n\r\n\t\t// Special case for a lone '+' sign\r\n\t\t// since it's not considered a possible phone number.\r\n\t\tif (!extracted_number)\r\n\t\t{\r\n\t\t\tif (text && text.indexOf('+') >= 0)\r\n\t\t\t{\r\n\t\t\t\textracted_number = '+'\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Validate possible first part of a phone number\r\n\t\tif (!VALID_INCOMPLETE_PHONE_NUMBER_PATTERN.test(extracted_number))\r\n\t\t{\r\n\t\t\treturn this.currentOutput\r\n\t\t}\r\n\r\n\t\treturn this.processInput(parseIncompletePhoneNumber(extracted_number))\r\n\t}\r\n\r\n\tprocessInput(input)\r\n\t{\r\n\t\t// If an out of position '+' sign detected\r\n\t\t// (or a second '+' sign),\r\n\t\t// then just drop it from the input.\r\n\t\tif (input[0] === '+')\r\n\t\t{\r\n\t\t\tif (!this.parsedInput)\r\n\t\t\t{\r\n\t\t\t\tthis.parsedInput += '+'\r\n\r\n\t\t\t\t// If a default country was set\r\n\t\t\t\t// then reset it because an explicitly international\r\n\t\t\t\t// phone number is being entered\r\n\t\t\t\tthis.resetCountriness()\r\n\t\t\t}\r\n\r\n\t\t\tinput = input.slice(1)\r\n\t\t}\r\n\r\n\t\t// Raw phone number\r\n\t\tthis.parsedInput += input\r\n\r\n\t\t// // Reset phone number validation state\r\n\t\t// this.valid = false\r\n\r\n\t\t// Add digits to the national number\r\n\t\tthis.nationalNumber += input\r\n\r\n\t\t// TODO: Deprecated: rename `this.nationalNumber`\r\n\t\t// to `this.nationalNumber` and remove `.getNationalNumber()`.\r\n\r\n\t\t// Try to format the parsed input\r\n\r\n\t\tif (this.isInternational())\r\n\t\t{\r\n\t\t\tif (!this.countryCallingCode)\r\n\t\t\t{\r\n\t\t\t\t// Extract country calling code from the digits entered so far.\r\n\r\n\t\t\t\t// There must be some digits in order to extract anything from them.\r\n\t\t\t\tif (!this.nationalNumber)\r\n\t\t\t\t{\r\n\t\t\t\t\t// Return raw phone number\r\n\t\t\t\t\treturn this.parsedInput\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If one looks at country phone codes\r\n\t\t\t\t// then he can notice that no one country phone code\r\n\t\t\t\t// is ever a (leftmost) substring of another country phone code.\r\n\t\t\t\t// So if a valid country code is extracted so far\r\n\t\t\t\t// then it means that this is the country code.\r\n\r\n\t\t\t\t// If no country phone code could be extracted so far,\r\n\t\t\t\t// then just return the raw phone number,\r\n\t\t\t\t// because it has no way of knowing\r\n\t\t\t\t// how to format the phone number so far.\r\n\t\t\t\tif (!this.extractCountryCallingCode())\r\n\t\t\t\t{\r\n\t\t\t\t\t// Return raw phone number\r\n\t\t\t\t\treturn this.parsedInput\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Initialize country-specific data\r\n\t\t\t\tthis.initialize_phone_number_formats_for_this_country_calling_code()\r\n\t\t\t\tthis.resetFormat()\r\n\t\t\t\tthis.determineTheCountry()\r\n\t\t\t}\r\n\t\t\t// `this.country` could be `undefined`,\r\n\t\t\t// for instance, when there is ambiguity\r\n\t\t\t// in a form of several different countries\r\n\t\t\t// each corresponding to the same country phone code\r\n\t\t\t// (e.g. NANPA: USA, Canada, etc),\r\n\t\t\t// and there's not enough digits entered\r\n\t\t\t// to reliably determine the country\r\n\t\t\t// the phone number belongs to.\r\n\t\t\t// Therefore, in cases of such ambiguity,\r\n\t\t\t// each time something is input,\r\n\t\t\t// try to determine the country\r\n\t\t\t// (if it's not determined yet).\r\n\t\t\telse if (!this.country)\r\n\t\t\t{\r\n\t\t\t\tthis.determineTheCountry()\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t// Some national prefixes are substrings of other national prefixes\r\n\t\t\t// (for the same country), therefore try to extract national prefix each time\r\n\t\t\t// because a longer national prefix might be available at some point in time.\r\n\r\n\t\t\tconst previous_national_prefix = this.nationalPrefix\r\n\t\t\tthis.nationalNumber = this.nationalPrefix + this.nationalNumber\r\n\r\n\t\t\t// Possibly extract a national prefix\r\n\t\t\tthis.extractNationalPrefix()\r\n\r\n\t\t\tif (this.nationalPrefix !== previous_national_prefix)\r\n\t\t\t{\r\n\t\t\t\t// National number has changed\r\n\t\t\t\t// (due to another national prefix been extracted)\r\n\t\t\t\t// therefore national number has changed\r\n\t\t\t\t// therefore reset all previous formatting data.\r\n\t\t\t\t// (and leading digits matching state)\r\n\t\t\t\tthis.matching_formats = undefined\r\n\t\t\t\tthis.resetFormat()\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if (!this.shouldFormat())\r\n\t\t// {\r\n\t\t// \treturn this.format_as_non_formatted_number()\r\n\t\t// }\r\n\r\n\t\tif (!this.nationalNumber)\r\n\t\t{\r\n\t\t\treturn this.format_as_non_formatted_number()\r\n\t\t}\r\n\r\n\t\t// Check the available phone number formats\r\n\t\t// based on the currently available leading digits.\r\n\t\tthis.match_formats_by_leading_digits()\r\n\r\n\t\t// Format the phone number (given the next digits)\r\n\t\tconst formatted_national_phone_number = this.formatNationalNumber(input)\r\n\r\n\t\t// If the phone number could be formatted,\r\n\t\t// then return it, possibly prepending with country phone code\r\n\t\t// (for international phone numbers only)\r\n\t\tif (formatted_national_phone_number)\r\n\t\t{\r\n\t\t\treturn this.formatFullNumber(formatted_national_phone_number)\r\n\t\t}\r\n\r\n\t\t// If the phone number couldn't be formatted,\r\n\t\t// then just fall back to the raw phone number.\r\n\t\treturn this.format_as_non_formatted_number()\r\n\t}\r\n\r\n\tformat_as_non_formatted_number()\r\n\t{\r\n\t\t// Strip national prefix for incorrectly inputted international phones.\r\n\t\tif (this.isInternational() && this.countryCallingCode)\r\n\t\t{\r\n\t\t\treturn `+${this.countryCallingCode}${this.nationalNumber}`\r\n\t\t}\r\n\r\n\t\treturn this.parsedInput\r\n\t}\r\n\r\n\tformatNationalNumber(next_digits)\r\n\t{\r\n\t\t// Format the next phone number digits\r\n\t\t// using the previously chosen phone number format.\r\n\t\t//\r\n\t\t// This is done here because if `attempt_to_format_complete_phone_number`\r\n\t\t// was placed before this call then the `template`\r\n\t\t// wouldn't reflect the situation correctly (and would therefore be inconsistent)\r\n\t\t//\r\n\t\tlet national_number_formatted_with_previous_format\r\n\t\tif (this.chosenFormat)\r\n\t\t{\r\n\t\t\tnational_number_formatted_with_previous_format = this.formatNextNationalNumberDigits(next_digits)\r\n\t\t}\r\n\r\n\t\t// See if the input digits can be formatted properly already. If not,\r\n\t\t// use the results from formatNextNationalNumberDigits(), which does formatting\r\n\t\t// based on the formatting pattern chosen.\r\n\r\n\t\tconst formatted_number = this.attempt_to_format_complete_phone_number()\r\n\r\n\t\t// Just because a phone number doesn't have a suitable format\r\n\t\t// that doesn't mean that the phone is invalid\r\n\t\t// because phone number formats only format phone numbers,\r\n\t\t// they don't validate them and some (rare) phone numbers\r\n\t\t// are meant to stay non-formatted.\r\n\t\tif (formatted_number)\r\n\t\t{\r\n\t\t\treturn formatted_number\r\n\t\t}\r\n\r\n\t\t// For some phone number formats national prefix\r\n\r\n\t\t// If the previously chosen phone number format\r\n\t\t// didn't match the next (current) digit being input\r\n\t\t// (leading digits pattern didn't match).\r\n\t\tif (this.chooseAnotherFormat())\r\n\t\t{\r\n\t\t\t// And a more appropriate phone number format\r\n\t\t\t// has been chosen for these `leading digits`,\r\n\t\t\t// then format the national phone number (so far)\r\n\t\t\t// using the newly selected phone number pattern.\r\n\r\n\t\t\t// Will return `undefined` if it couldn't format\r\n\t\t\t// the supplied national number\r\n\t\t\t// using the selected phone number pattern.\r\n\r\n\t\t\treturn this.reformatNationalNumber()\r\n\t\t}\r\n\r\n\t\t// If could format the next (current) digit\r\n\t\t// using the previously chosen phone number format\r\n\t\t// then return the formatted number so far.\r\n\r\n\t\t// If no new phone number format could be chosen,\r\n\t\t// and couldn't format the supplied national number\r\n\t\t// using the selected phone number pattern,\r\n\t\t// then it will return `undefined`.\r\n\r\n\t\treturn national_number_formatted_with_previous_format\r\n\t}\r\n\r\n\treset()\r\n\t{\r\n\t\t// Input stripped of non-phone-number characters.\r\n\t\t// Can only contain a possible leading '+' sign and digits.\r\n\t\tthis.parsedInput = ''\r\n\r\n\t\tthis.currentOutput = ''\r\n\r\n\t\t// This contains the national prefix that has been extracted. It contains only\r\n\t\t// digits without formatting.\r\n\t\tthis.nationalPrefix = ''\r\n\r\n\t\tthis.nationalNumber = ''\r\n\t\tthis.carrierCode = ''\r\n\r\n\t\tthis.resetCountriness()\r\n\r\n\t\tthis.resetFormat()\r\n\r\n\t\treturn this\r\n\t}\r\n\r\n\tresetCountry()\r\n\t{\r\n\t\tif (this.isInternational()) {\r\n\t\t\tthis.country = undefined\r\n\t\t} else {\r\n\t\t\tthis.country = this.defaultCountry\r\n\t\t}\r\n\t}\r\n\r\n\tresetCountriness()\r\n\t{\r\n\t\tthis.resetCountry()\r\n\r\n\t\tif (this.defaultCountry && !this.isInternational())\r\n\t\t{\r\n\t\t\tthis.metadata.country(this.defaultCountry)\r\n\t\t\tthis.countryCallingCode = this.metadata.countryCallingCode()\r\n\r\n\t\t\tthis.initialize_phone_number_formats_for_this_country_calling_code()\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.metadata.country(undefined)\r\n\t\t\tthis.countryCallingCode = undefined\r\n\r\n\t\t\t// \"Available formats\" are all formats available for the country.\r\n\t\t\t// \"Matching formats\" are only formats eligible for the national number being entered.\r\n\t\t\tthis.available_formats = []\r\n\t\t\tthis.matching_formats = undefined\r\n\t\t}\r\n\t}\r\n\r\n\tresetFormat()\r\n\t{\r\n\t\tthis.chosenFormat = undefined\r\n\t\tthis.template = undefined\r\n\t\tthis.partially_populated_template = undefined\r\n\t\tthis.last_match_position = -1\r\n\t}\r\n\r\n\t// Format each digit of national phone number (so far)\r\n\t// using the newly selected phone number pattern.\r\n\treformatNationalNumber()\r\n\t{\r\n\t\t// Format each digit of national phone number (so far)\r\n\t\t// using the selected phone number pattern.\r\n\t\treturn this.formatNextNationalNumberDigits(this.nationalNumber)\r\n\t}\r\n\r\n\tinitialize_phone_number_formats_for_this_country_calling_code()\r\n\t{\r\n\t\t// Get all \"eligible\" phone number formats for this country\r\n\t\tthis.available_formats = this.metadata.formats().filter((format) =>\r\n\t\t{\r\n\t\t\treturn ELIGIBLE_FORMAT_PATTERN.test(format.internationalFormat())\r\n\t\t})\r\n\r\n\t\tthis.matching_formats = undefined\r\n\t}\r\n\r\n\tmatch_formats_by_leading_digits()\r\n\t{\r\n\t\tconst leading_digits = this.nationalNumber\r\n\r\n\t\t// \"leading digits\" pattern list starts with a\r\n\t\t// \"leading digits\" pattern fitting a maximum of 3 leading digits.\r\n\t\t// So, after a user inputs 3 digits of a national (significant) phone number\r\n\t\t// this national (significant) number can already be formatted.\r\n\t\t// The next \"leading digits\" pattern is for 4 leading digits max,\r\n\t\t// and the \"leading digits\" pattern after it is for 5 leading digits max, etc.\r\n\r\n\t\t// This implementation is different from Google's\r\n\t\t// in that it searches for a fitting format\r\n\t\t// even if the user has entered less than\r\n\t\t// `MIN_LEADING_DIGITS_LENGTH` digits of a national number.\r\n\t\t// Because some leading digits patterns already match for a single first digit.\r\n\t\tlet index_of_leading_digits_pattern = leading_digits.length - MIN_LEADING_DIGITS_LENGTH\r\n\t\tif (index_of_leading_digits_pattern < 0) {\r\n\t\t\tindex_of_leading_digits_pattern = 0\r\n\t\t}\r\n\r\n\t\t// \"Available formats\" are all formats available for the country.\r\n\t\t// \"Matching formats\" are only formats eligible for the national number being entered.\r\n\r\n\t\t// If at least `MIN_LEADING_DIGITS_LENGTH` digits of a national number are available\r\n\t\t// then format matching starts narrowing down the list of possible formats\r\n\t\t// (only previously matched formats are considered for next digits).\r\n\t\tconst available_formats = this.had_enough_leading_digits && this.matching_formats || this.available_formats\r\n\t\tthis.had_enough_leading_digits = this.shouldFormat()\r\n\r\n\t\tthis.matching_formats = available_formats.filter((format) =>\r\n\t\t{\r\n\t\t\tconst leading_digits_patterns_count = format.leadingDigitsPatterns().length\r\n\r\n\t\t\t// If this format is not restricted to a certain\r\n\t\t\t// leading digits pattern then it fits.\r\n\t\t\tif (leading_digits_patterns_count === 0)\r\n\t\t\t{\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\r\n\t\t\tconst leading_digits_pattern_index = Math.min(index_of_leading_digits_pattern, leading_digits_patterns_count - 1)\r\n\t\t\tconst leading_digits_pattern = format.leadingDigitsPatterns()[leading_digits_pattern_index]\r\n\r\n\t\t\t// Brackets are required for `^` to be applied to\r\n\t\t\t// all or-ed (`|`) parts, not just the first one.\r\n\t\t\treturn new RegExp(`^(${leading_digits_pattern})`).test(leading_digits)\r\n\t\t})\r\n\r\n\t\t// If there was a phone number format chosen\r\n\t\t// and it no longer holds given the new leading digits then reset it.\r\n\t\t// The test for this `if` condition is marked as:\r\n\t\t// \"Reset a chosen format when it no longer holds given the new leading digits\".\r\n\t\t// To construct a valid test case for this one can find a country\r\n\t\t// in `PhoneNumberMetadata.xml` yielding one format for 3 `<leadingDigits>`\r\n\t\t// and yielding another format for 4 `<leadingDigits>` (Australia in this case).\r\n\t\tif (this.chosenFormat && this.matching_formats.indexOf(this.chosenFormat) === -1)\r\n\t\t{\r\n\t\t\tthis.resetFormat()\r\n\t\t}\r\n\t}\r\n\r\n\tshouldFormat()\r\n\t{\r\n\t\t// Start matching any formats at all when the national number\r\n\t\t// entered so far is at least 3 digits long,\r\n\t\t// otherwise format matching would give false negatives\r\n\t\t// like when the digits entered so far are `2`\r\n\t\t// and the leading digits pattern is `21` –\r\n\t\t// it's quite obvious in this case that the format could be the one\r\n\t\t// but due to the absence of further digits it would give false negative.\r\n\t\t//\r\n\t\t// Presumably the limitation of \"3 digits min\"\r\n\t\t// is imposed to exclude false matches,\r\n\t\t// e.g. when there are two different formats\r\n\t\t// each one fitting one or two leading digits being input.\r\n\t\t// But for this case I would propose a specific `if/else` condition.\r\n\t\t//\r\n\t\treturn this.nationalNumber.length >= MIN_LEADING_DIGITS_LENGTH\r\n\t}\r\n\r\n\t// Check to see if there is an exact pattern match for these digits. If so, we\r\n\t// should use this instead of any other formatting template whose\r\n\t// `leadingDigitsPattern` also matches the input.\r\n\tattempt_to_format_complete_phone_number()\r\n\t{\r\n\t\tfor (const format of this.matching_formats)\r\n\t\t{\r\n\t\t\tconst matcher = new RegExp(`^(?:${format.pattern()})$`)\r\n\r\n\t\t\tif (!matcher.test(this.nationalNumber))\r\n\t\t\t{\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.isFormatApplicable(format))\r\n\t\t\t{\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\t// To leave the formatter in a consistent state\r\n\t\t\tthis.resetFormat()\r\n\t\t\tthis.chosenFormat = format\r\n\r\n\t\t\tlet formatted_number = format_national_number_using_format\r\n\t\t\t(\r\n\t\t\t\tthis.nationalNumber,\r\n\t\t\t\tformat,\r\n\t\t\t\tthis.isInternational(),\r\n\t\t\t\tthis.nationalPrefix !== '',\r\n\t\t\t\tthis.metadata\r\n\t\t\t)\r\n\r\n\t\t\t// Special handling for NANPA countries for AsYouType formatter.\r\n\t\t\t// Copied from Google's `libphonenumber`:\r\n\t\t\t// https://github.com/googlei18n/libphonenumber/blob/66986dbbe443ee8450e2b54dcd44ac384b3bbee8/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L535-L573\r\n\t\t\tif (this.nationalPrefix && this.countryCallingCode === '1') {\r\n\t\t\t\tformatted_number = '1 ' + formatted_number\r\n\t\t\t}\r\n\r\n\t\t\t// Set `this.template` and `this.partially_populated_template`.\r\n\t\t\t//\r\n\t\t\t// `else` case doesn't ever happen\r\n\t\t\t// with the current metadata,\r\n\t\t\t// but just in case.\r\n\t\t\t//\r\n\t\t\t/* istanbul ignore else */\r\n\t\t\tif (this.createFormattingTemplate(format))\r\n\t\t\t{\r\n\t\t\t\t// Populate `this.partially_populated_template`\r\n\t\t\t\tthis.reformatNationalNumber()\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\t// Prepend `+CountryCode` in case of an international phone number\r\n\t\t\t\tconst full_number = this.formatFullNumber(formatted_number)\r\n\t\t\t\tthis.template = full_number.replace(/[\\d\\+]/g, DIGIT_PLACEHOLDER)\r\n\t\t\t\tthis.partially_populated_template = full_number\r\n\t\t\t}\r\n\r\n\t\t\treturn formatted_number\r\n\t\t}\r\n\t}\r\n\r\n\t// Prepends `+CountryCode` in case of an international phone number\r\n\tformatFullNumber(formattedNationalNumber)\r\n\t{\r\n\t\tif (this.isInternational()) {\r\n\t\t\treturn `+${this.countryCallingCode} ${formattedNationalNumber}`\r\n\t\t}\r\n\t\treturn formattedNationalNumber\r\n\t}\r\n\r\n\t// Extracts the country calling code from the beginning\r\n\t// of the entered `national_number` (so far),\r\n\t// and places the remaining input into the `national_number`.\r\n\textractCountryCallingCode()\r\n\t{\r\n\t\tconst { countryCallingCode, number } = extractCountryCallingCode(this.parsedInput, this.defaultCountry, this.metadata.metadata)\r\n\r\n\t\tif (!countryCallingCode)\r\n\t\t{\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tthis.countryCallingCode = countryCallingCode\r\n\r\n\t\t// Sometimes people erroneously write national prefix\r\n\t\t// as part of an international number, e.g. +44 (0) ....\r\n\t\t// This violates the standards for international phone numbers,\r\n\t\t// so \"As You Type\" formatter assumes no national prefix\r\n\t\t// when parsing a phone number starting from `+`.\r\n\t\t// Even if it did attempt to filter-out that national prefix\r\n\t\t// it would look weird for a user trying to enter a digit\r\n\t\t// because from user's perspective the keyboard \"wouldn't be working\".\r\n\t\tthis.nationalNumber = number\r\n\r\n\t\tthis.metadata.chooseCountryByCountryCallingCode(countryCallingCode)\r\n\t\treturn this.metadata.selectedCountry() !== undefined\r\n\t}\r\n\r\n\textractNationalPrefix()\r\n\t{\r\n\t\tthis.nationalPrefix = ''\r\n\r\n\t\tif (!this.metadata.selectedCountry()) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Only strip national prefixes for non-international phone numbers\r\n\t\t// because national prefixes can't be present in international phone numbers.\r\n\t\t// While `parseNumber()` is forgiving is such cases, `AsYouType` is not.\r\n\t\tconst { number: potential_national_number, carrierCode } = strip_national_prefix_and_carrier_code(this.nationalNumber, this.metadata)\r\n\r\n\t\tif (carrierCode) {\r\n\t\t\tthis.carrierCode = carrierCode\r\n\t\t}\r\n\r\n\t\t// We require that the NSN remaining after stripping the national prefix and\r\n\t\t// carrier code be long enough to be a possible length for the region.\r\n\t\t// Otherwise, we don't do the stripping, since the original number could be\r\n\t\t// a valid short number.\r\n\t\tif (!this.metadata.possibleLengths() ||\r\n\t\t\tthis.isPossibleNumber(this.nationalNumber) &&\r\n\t\t\t!this.isPossibleNumber(potential_national_number))\r\n\t\t{\r\n\t\t\t// Verify the parsed national (significant) number for this country\r\n\t\t\t//\r\n\t\t\t// If the original number (before stripping national prefix) was viable,\r\n\t\t\t// and the resultant number is not, then prefer the original phone number.\r\n\t\t\t// This is because for some countries (e.g. Russia) the same digit could be both\r\n\t\t\t// a national prefix and a leading digit of a valid national phone number,\r\n\t\t\t// like `8` is the national prefix for Russia and both\r\n\t\t\t// `8 800 555 35 35` and `800 555 35 35` are valid numbers.\r\n\t\t\tif (matchesEntirely(this.nationalNumber, this.metadata.nationalNumberPattern()) &&\r\n\t\t\t\t!matchesEntirely(potential_national_number, this.metadata.nationalNumberPattern()))\r\n\t\t\t{\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.nationalPrefix = this.nationalNumber.slice(0, this.nationalNumber.length - potential_national_number.length)\r\n\t\tthis.nationalNumber = potential_national_number\r\n\r\n\t\treturn this.nationalPrefix\r\n\t}\r\n\r\n\tisPossibleNumber(number)\r\n\t{\r\n\t\tconst validation_result = checkNumberLengthForType(number, undefined, this.metadata)\r\n\t\tswitch (validation_result)\r\n\t\t{\r\n\t\t\tcase 'IS_POSSIBLE':\r\n\t\t\t\treturn true\r\n\t\t\t// case 'IS_POSSIBLE_LOCAL_ONLY':\r\n\t\t\t// \treturn !this.isInternational()\r\n\t\t\tdefault:\r\n\t\t\t\treturn false\r\n\t\t}\r\n\t}\r\n\r\n\tchooseAnotherFormat()\r\n\t{\r\n\t\t// When there are multiple available formats, the formatter uses the first\r\n\t\t// format where a formatting template could be created.\r\n\t\tfor (const format of this.matching_formats)\r\n\t\t{\r\n\t\t\t// If this format is currently being used\r\n\t\t\t// and is still possible, then stick to it.\r\n\t\t\tif (this.chosenFormat === format) {\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\t// If this `format` is suitable for \"as you type\",\r\n\t\t\t// then extract the template from this format\r\n\t\t\t// and use it to format the phone number being input.\r\n\r\n\t\t\tif (!this.isFormatApplicable(format)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.createFormattingTemplate(format)) {\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\r\n\t\t\tthis.chosenFormat = format\r\n\r\n\t\t\t// With a new formatting template, the matched position\r\n\t\t\t// using the old template needs to be reset.\r\n\t\t\tthis.last_match_position = -1\r\n\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\t// No format matches the phone number,\r\n\t\t// therefore set `country` to `undefined`\r\n\t\t// (or to the default country).\r\n\t\tthis.resetCountry()\r\n\r\n\t\t// No format matches the national phone number entered\r\n\t\tthis.resetFormat()\r\n\t}\r\n\r\n\tisFormatApplicable(format)\r\n\t{\r\n\t\t// If national prefix is mandatory for this phone number format\r\n\t\t// and the user didn't input the national prefix\r\n\t\t// then this phone number format isn't suitable.\r\n\t\tif (!this.isInternational() && !this.nationalPrefix && format.nationalPrefixIsMandatoryWhenFormatting()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// If this format doesn't use national prefix\r\n\t\t// but the user did input national prefix\r\n\t\t// then this phone number format isn't suitable.\r\n\t\tif (this.nationalPrefix && !format.usesNationalPrefix() && !format.nationalPrefixIsOptionalWhenFormatting()) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\treturn true\r\n\t}\r\n\r\n\tcreateFormattingTemplate(format)\r\n\t{\r\n\t\t// The formatter doesn't format numbers when numberPattern contains '|', e.g.\r\n\t\t// (20|3)\\d{4}. In those cases we quickly return.\r\n\t\t// (Though there's no such format in current metadata)\r\n\t\t/* istanbul ignore if */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS && format.pattern().indexOf('|') >= 0) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Get formatting template for this phone number format\r\n\t\tconst template = this.getTemplateForNumberFormatPattern(format)\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (!template) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// This one is for national number only\r\n\t\tthis.partially_populated_template = template\r\n\r\n\t\t// For convenience, the public `.template` property\r\n\t\t// contains the whole international number\r\n\t\t// if the phone number being input is international:\r\n\t\t// 'x' for the '+' sign, 'x'es for the country phone code,\r\n\t\t// a spacebar and then the template for the formatted national number.\r\n\t\tif (this.isInternational()) {\r\n\t\t\tthis.template = DIGIT_PLACEHOLDER + repeat(DIGIT_PLACEHOLDER, this.countryCallingCode.length) + ' ' + template\r\n\t\t}\r\n\t\t// For local numbers, replace national prefix\r\n\t\t// with a digit placeholder.\r\n\t\telse {\r\n\t\t\tthis.template = template.replace(/\\d/g, DIGIT_PLACEHOLDER)\r\n\t\t}\r\n\r\n\t\t// This one is for the full phone number\r\n\t\treturn this.template\r\n\t}\r\n\r\n\t// Generates formatting template for a phone number format\r\n\tgetTemplateForNumberFormatPattern(format)\r\n\t{\r\n\t\t// A very smart trick by the guys at Google\r\n\t\tlet number_pattern = format.pattern()\r\n\r\n\t\t/* istanbul ignore else */\r\n\t\tif (SUPPORT_LEGACY_FORMATTING_PATTERNS)\r\n\t\t{\r\n\t\t\tnumber_pattern = number_pattern\r\n\t\t\t\t// Replace anything in the form of [..] with \\d\r\n\t\t\t\t.replace(CREATE_CHARACTER_CLASS_PATTERN(), '\\\\d')\r\n\t\t\t\t// Replace any standalone digit (not the one in `{}`) with \\d\r\n\t\t\t\t.replace(CREATE_STANDALONE_DIGIT_PATTERN(), '\\\\d')\r\n\t\t}\r\n\r\n\t\t// This match will always succeed,\r\n\t\t// because the \"longest dummy phone number\"\r\n\t\t// has enough length to accomodate any possible\r\n\t\t// national phone number format pattern.\r\n\t\tlet dummy_phone_number_matching_format_pattern = LONGEST_DUMMY_PHONE_NUMBER.match(number_pattern)[0]\r\n\r\n\t\t// If the national number entered is too long\r\n\t\t// for any phone number format, then abort.\r\n\t\tif (this.nationalNumber.length > dummy_phone_number_matching_format_pattern.length) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\t// Prepare the phone number format\r\n\t\tconst number_format = this.getFormatFormat(format)\r\n\r\n\t\t// Get a formatting template which can be used to efficiently format\r\n\t\t// a partial number where digits are added one by one.\r\n\r\n\t\t// Below `strict_pattern` is used for the\r\n\t\t// regular expression (with `^` and `$`).\r\n\t\t// This wasn't originally in Google's `libphonenumber`\r\n\t\t// and I guess they don't really need it\r\n\t\t// because they're not using \"templates\" to format phone numbers\r\n\t\t// but I added `strict_pattern` after encountering\r\n\t\t// South Korean phone number formatting bug.\r\n\t\t//\r\n\t\t// Non-strict regular expression bug demonstration:\r\n\t\t//\r\n\t\t// this.nationalNumber : `111111111` (9 digits)\r\n\t\t//\r\n\t\t// number_pattern : (\\d{2})(\\d{3,4})(\\d{4})\r\n\t\t// number_format : `$1 $2 $3`\r\n\t\t// dummy_phone_number_matching_format_pattern : `9999999999` (10 digits)\r\n\t\t//\r\n\t\t// '9999999999'.replace(new RegExp(/(\\d{2})(\\d{3,4})(\\d{4})/g), '$1 $2 $3') = \"99 9999 9999\"\r\n\t\t//\r\n\t\t// template : xx xxxx xxxx\r\n\t\t//\r\n\t\t// But the correct template in this case is `xx xxx xxxx`.\r\n\t\t// The template was generated incorrectly because of the\r\n\t\t// `{3,4}` variability in the `number_pattern`.\r\n\t\t//\r\n\t\t// The fix is, if `this.nationalNumber` has already sufficient length\r\n\t\t// to satisfy the `number_pattern` completely then `this.nationalNumber` is used\r\n\t\t// instead of `dummy_phone_number_matching_format_pattern`.\r\n\r\n\t\tconst strict_pattern = new RegExp('^' + number_pattern + '$')\r\n\t\tconst national_number_dummy_digits = this.nationalNumber.replace(/\\d/g, DUMMY_DIGIT)\r\n\r\n\t\t// If `this.nationalNumber` has already sufficient length\r\n\t\t// to satisfy the `number_pattern` completely then use it\r\n\t\t// instead of `dummy_phone_number_matching_format_pattern`.\r\n\t\tif (strict_pattern.test(national_number_dummy_digits)) {\r\n\t\t\tdummy_phone_number_matching_format_pattern = national_number_dummy_digits\r\n\t\t}\r\n\r\n\t\t// Generate formatting template for this phone number format\r\n\t\treturn dummy_phone_number_matching_format_pattern\r\n\t\t\t// Format the dummy phone number according to the format\r\n\t\t\t.replace(new RegExp(number_pattern), number_format)\r\n\t\t\t// Replace each dummy digit with a DIGIT_PLACEHOLDER\r\n\t\t\t.replace(new RegExp(DUMMY_DIGIT, 'g'), DIGIT_PLACEHOLDER)\r\n\t}\r\n\r\n\tformatNextNationalNumberDigits(digits)\r\n\t{\r\n\t\t// Using `.split('')` to iterate through a string here\r\n\t\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t\t// `.split('')` is generally not safe for Unicode,\r\n\t\t// but in this particular case for `digits` it is safe.\r\n\t\t// for (const digit of digits)\r\n\t\tfor (const digit of digits.split(''))\r\n\t\t{\r\n\t\t\t// If there is room for more digits in current `template`,\r\n\t\t\t// then set the next digit in the `template`,\r\n\t\t\t// and return the formatted digits so far.\r\n\r\n\t\t\t// If more digits are entered than the current format could handle\r\n\t\t\tif (this.partially_populated_template.slice(this.last_match_position + 1).search(DIGIT_PLACEHOLDER_MATCHER) === -1)\r\n\t\t\t{\r\n\t\t\t\t// Reset the current format,\r\n\t\t\t\t// so that the new format will be chosen\r\n\t\t\t\t// in a subsequent `this.chooseAnotherFormat()` call\r\n\t\t\t\t// later in code.\r\n\t\t\t\tthis.chosenFormat = undefined\r\n\t\t\t\tthis.template = undefined\r\n\t\t\t\tthis.partially_populated_template = undefined\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\r\n\t\t\tthis.last_match_position = this.partially_populated_template.search(DIGIT_PLACEHOLDER_MATCHER)\r\n\t\t\tthis.partially_populated_template = this.partially_populated_template.replace(DIGIT_PLACEHOLDER_MATCHER, digit)\r\n\t\t}\r\n\r\n\t\t// Return the formatted phone number so far.\r\n\t\treturn cut_stripping_dangling_braces(this.partially_populated_template, this.last_match_position + 1)\r\n\r\n\t\t// The old way which was good for `input-format` but is not so good\r\n\t\t// for `react-phone-number-input`'s default input (`InputBasic`).\r\n\t\t// return close_dangling_braces(this.partially_populated_template, this.last_match_position + 1)\r\n\t\t// \t.replace(DIGIT_PLACEHOLDER_MATCHER_GLOBAL, ' ')\r\n\t}\r\n\r\n\tisInternational() {\r\n\t\treturn this.parsedInput && this.parsedInput[0] === '+'\r\n\t}\r\n\r\n\tgetFormatFormat(format)\r\n\t{\r\n\t\tif (this.isInternational()) {\r\n\t\t\treturn changeInternationalFormatStyle(format.internationalFormat())\r\n\t\t}\r\n\r\n\t\t// If national prefix formatting rule is set\r\n\t\t// for this phone number format\r\n\t\tif (format.nationalPrefixFormattingRule())\r\n\t\t{\r\n\t\t\t// If the user did input the national prefix\r\n\t\t\t// (or if the national prefix formatting rule does not require national prefix)\r\n\t\t\t// then maybe make it part of the phone number template\r\n\t\t\tif (this.nationalPrefix || !format.usesNationalPrefix())\r\n\t\t\t{\r\n\t\t\t\t// Make the national prefix part of the phone number template\r\n\t\t\t\treturn format.format().replace(FIRST_GROUP_PATTERN, format.nationalPrefixFormattingRule())\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Special handling for NANPA countries for AsYouType formatter.\r\n\t\t// Copied from Google's `libphonenumber`:\r\n\t\t// https://github.com/googlei18n/libphonenumber/blob/66986dbbe443ee8450e2b54dcd44ac384b3bbee8/java/libphonenumber/src/com/google/i18n/phonenumbers/AsYouTypeFormatter.java#L535-L573\r\n\t\telse if (this.countryCallingCode === '1' && this.nationalPrefix === '1') {\r\n\t\t\treturn `1 ${format.format()}`\r\n\t\t}\r\n\r\n\t\treturn format.format()\r\n\t}\r\n\r\n\t// Determines the country of the phone number\r\n\t// entered so far based on the country phone code\r\n\t// and the national phone number.\r\n\tdetermineTheCountry() {\r\n\t\tthis.country = find_country_code(this.countryCallingCode, this.nationalNumber, this.metadata)\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an instance of `PhoneNumber` class.\r\n\t * Will return `undefined` if no national (significant) number\r\n\t * digits have been entered so far, or if no `defaultCountry` has been\r\n\t * set and the user enters a phone number not in international format.\r\n\t */\r\n\tgetNumber()\r\n\t{\r\n\t\tif (!this.countryCallingCode || !this.nationalNumber) {\r\n\t\t\treturn undefined\r\n\t\t}\r\n\t\tconst phoneNumber = new PhoneNumber(this.country || this.countryCallingCode, this.nationalNumber, this.metadata.metadata)\r\n\t\tif (this.carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = this.carrierCode\r\n\t\t}\r\n\t\t// Phone number extensions are not supported by \"As You Type\" formatter.\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\tgetNationalNumber() {\r\n\t\treturn this.nationalNumber\r\n\t}\r\n\r\n\tgetTemplate()\r\n\t{\r\n\t\tif (!this.template) {\r\n\t\t\treturn\r\n\t\t}\r\n\r\n\t\tlet index = -1\r\n\r\n\t\tlet i = 0\r\n\t\twhile (i < this.parsedInput.length)\r\n\t\t{\r\n\t\t\tindex = this.template.indexOf(DIGIT_PLACEHOLDER, index + 1)\r\n\t\t\ti++\r\n\t\t}\r\n\r\n\t\treturn cut_stripping_dangling_braces(this.template, index + 1)\r\n\t}\r\n}\r\n\r\nexport function strip_dangling_braces(string)\r\n{\r\n\tconst dangling_braces =[]\r\n\tlet i = 0\r\n\twhile (i < string.length)\r\n\t{\r\n\t\tif (string[i] === '(') {\r\n\t\t\tdangling_braces.push(i)\r\n\t\t}\r\n\t\telse if (string[i] === ')') {\r\n\t\t\tdangling_braces.pop()\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n\r\n\tlet start = 0\r\n\tlet cleared_string = ''\r\n\tdangling_braces.push(string.length)\r\n\tfor (const index of dangling_braces)\r\n\t{\r\n\t\tcleared_string += string.slice(start, index)\r\n\t\tstart = index + 1\r\n\t}\r\n\r\n\treturn cleared_string\r\n}\r\n\r\nexport function cut_stripping_dangling_braces(string, cut_before_index)\r\n{\r\n\tif (string[cut_before_index] === ')') {\r\n\t\tcut_before_index++\r\n\t}\r\n\treturn strip_dangling_braces(string.slice(0, cut_before_index))\r\n}\r\n\r\nexport function close_dangling_braces(template, cut_before)\r\n{\r\n\tconst retained_template = template.slice(0, cut_before)\r\n\r\n\tconst opening_braces = count_occurences('(', retained_template)\r\n\tconst closing_braces = count_occurences(')', retained_template)\r\n\r\n\tlet dangling_braces = opening_braces - closing_braces\r\n\twhile (dangling_braces > 0 && cut_before < template.length)\r\n\t{\r\n\t\tif (template[cut_before] === ')')\r\n\t\t{\r\n\t\t\tdangling_braces--\r\n\t\t}\r\n\t\tcut_before++\r\n\t}\r\n\r\n\treturn template.slice(0, cut_before)\r\n}\r\n\r\n// Counts all occurences of a symbol in a string.\r\n// Unicode-unsafe (because using `.split()`).\r\nexport function count_occurences(symbol, string)\r\n{\r\n\tlet count = 0\r\n\r\n\t// Using `.split('')` to iterate through a string here\r\n\t// to avoid requiring `Symbol.iterator` polyfill.\r\n\t// `.split('')` is generally not safe for Unicode,\r\n\t// but in this particular case for counting brackets it is safe.\r\n\t// for (const character of string)\r\n\tfor (const character of string.split(''))\r\n\t{\r\n\t\tif (character === symbol)\r\n\t\t{\r\n\t\t\tcount++\r\n\t\t}\r\n\t}\r\n\r\n\treturn count\r\n}\r\n\r\n// Repeats a string (or a symbol) N times.\r\n// http://stackoverflow.com/questions/202605/repeat-string-javascript\r\nexport function repeat(string, times)\r\n{\r\n\tif (times < 1)\r\n\t{\r\n\t\treturn ''\r\n\t}\r\n\r\n\tlet result = ''\r\n\r\n\twhile (times > 1)\r\n\t{\r\n\t\tif (times & 1)\r\n\t\t{\r\n\t\t\tresult += string\r\n\t\t}\r\n\r\n\t\ttimes >>= 1\r\n\t\tstring += string\r\n\t}\r\n\r\n\treturn result + string\r\n}"]}