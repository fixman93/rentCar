{"version":3,"sources":["../source/extension.js"],"names":["VALID_DIGITS","RFC3966_EXTN_PREFIX","CAPTURING_EXTN_DIGITS","create_extension_pattern","purpose","single_extension_characters","EXTN_PATTERNS_FOR_PARSING","EXTN_PATTERNS_FOR_MATCHING","EXTN_PATTERN","RegExp","extractExtension","number","start","search","number_without_extension","slice","matches","match","i","length","ext"],"mappings":"AAAA,SAASA,YAAT,QAA6B,aAA7B;;AAEA;AACA,IAAMC,sBAAsB,OAA5B;;AAEA;AACA;AACA,IAAMC,wBAAwB,OAAOF,YAAP,GAAsB,SAApD;;AAEA;;;;;;;;;;;;;;;AAeA,SAASG,wBAAT,CAAkCC,OAAlC,EACA;AACC;AACA,KAAIC,8BAA8B,uBAAlC;;AAEA,SAAQD,OAAR;AAEC;AACA;AACA,OAAK,SAAL;AACCC,iCAA8B,OAAOA,2BAArC;AALF;;AAQA,QAAOJ,sBACNC,qBADM,GACkB,GADlB,GAEN,cAFM,GAGN,iEAHM;AAIN;AACA,sBALM,GAMN,GANM,GAMAG,2BANA,GAM8B,iCAN9B,GAON,4BAPM,GAQNH,qBARM,GAQkB,KARlB,GASN,SATM,GASMF,YATN,GASqB,UAT5B;AAUA;;AAED;;;;;;;;;;;;;;;AAeA,OAAO,IAAMM,4BAA4BH,yBAAyB,SAAzB,CAAlC;;AAEP,OAAO,IAAMI,6BAA6BJ,yBAAyB,UAAzB,CAAnC;;AAEP;AACA;AACA,IAAMK,eAAe,IAAIC,MAAJ,CAAW,QAAQH,yBAAR,GAAoC,IAA/C,EAAqD,GAArD,CAArB;;AAEA;AACA;AACA;AACA,OAAO,SAASI,gBAAT,CAA0BC,MAA1B,EACP;AACC,KAAMC,QAAQD,OAAOE,MAAP,CAAcL,YAAd,CAAd;AACA,KAAII,QAAQ,CAAZ,EAAe;AACd,SAAO,EAAP;AACA;;AAED;AACA;AACA,KAAME,2BAA2BH,OAAOI,KAAP,CAAa,CAAb,EAAgBH,KAAhB,CAAjC;;AAEA,KAAMI,UAAUL,OAAOM,KAAP,CAAaT,YAAb,CAAhB;AACA,KAAIU,IAAI,CAAR;AACA,QAAOA,IAAIF,QAAQG,MAAnB,EACA;AACC,MAAIH,QAAQE,CAAR,KAAc,IAAd,IAAsBF,QAAQE,CAAR,EAAWC,MAAX,GAAoB,CAA9C,EACA;AACC,UAAO;AACNR,YAASG,wBADH;AAENM,SAASJ,QAAQE,CAAR;AAFH,IAAP;AAIA;AACDA;AACA;AACD","file":"extension.js","sourcesContent":["import { VALID_DIGITS } from './constants'\r\n\r\n// The RFC 3966 format for extensions.\r\nconst RFC3966_EXTN_PREFIX = ';ext='\r\n\r\n// Pattern to capture digits used in an extension.\r\n// Places a maximum length of '7' for an extension.\r\nconst CAPTURING_EXTN_DIGITS = '([' + VALID_DIGITS + ']{1,7})'\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nfunction create_extension_pattern(purpose)\r\n{\r\n\t// One-character symbols that can be used to indicate an extension.\r\n\tlet single_extension_characters = 'x\\uFF58#\\uFF03~\\uFF5E'\r\n\r\n\tswitch (purpose)\r\n\t{\r\n\t\t// For parsing, we are slightly more lenient in our interpretation than for matching. Here we\r\n\t\t// allow \"comma\" and \"semicolon\" as possible extension indicators. When matching, these are\r\n\t\tcase 'parsing':\r\n\t\t\tsingle_extension_characters = ',;' + single_extension_characters\r\n\t}\r\n\r\n\treturn RFC3966_EXTN_PREFIX +\r\n\t\tCAPTURING_EXTN_DIGITS + '|' +\r\n\t\t'[ \\u00A0\\\\t,]*' +\r\n\t\t'(?:e?xt(?:ensi(?:o\\u0301?|\\u00F3))?n?|\\uFF45?\\uFF58\\uFF54\\uFF4E?|' +\r\n\t\t// \"доб.\"\r\n\t\t'\\u0434\\u043E\\u0431|' +\r\n\t\t'[' + single_extension_characters + ']|int|anexo|\\uFF49\\uFF4E\\uFF54)' +\r\n\t\t'[:\\\\.\\uFF0E]?[ \\u00A0\\\\t,-]*' +\r\n\t\tCAPTURING_EXTN_DIGITS + '#?|' +\r\n\t\t'[- ]+([' + VALID_DIGITS + ']{1,5})#'\r\n}\r\n\r\n/**\r\n * Regexp of all possible ways to write extensions, for use when parsing. This\r\n * will be run as a case-insensitive regexp match. Wide character versions are\r\n * also provided after each ASCII version. There are three regular expressions\r\n * here. The first covers RFC 3966 format, where the extension is added using\r\n * ';ext='. The second more generic one starts with optional white space and\r\n * ends with an optional full stop (.), followed by zero or more spaces/tabs\r\n * /commas and then the numbers themselves. The other one covers the special\r\n * case of American numbers where the extension is written with a hash at the\r\n * end, such as '- 503#'. Note that the only capturing groups should be around\r\n * the digits that you want to capture as part of the extension, or else parsing\r\n * will fail! We allow two options for representing the accented o - the\r\n * character itself, and one in the unicode decomposed form with the combining\r\n * acute accent.\r\n */\r\nexport const EXTN_PATTERNS_FOR_PARSING = create_extension_pattern('parsing')\r\n\r\nexport const EXTN_PATTERNS_FOR_MATCHING = create_extension_pattern('matching')\r\n\r\n// Regexp of all known extension prefixes used by different regions followed by\r\n// 1 or more valid digits, for use when parsing.\r\nconst EXTN_PATTERN = new RegExp('(?:' + EXTN_PATTERNS_FOR_PARSING + ')$', 'i')\r\n\r\n// Strips any extension (as in, the part of the number dialled after the call is\r\n// connected, usually indicated with extn, ext, x or similar) from the end of\r\n// the number, and returns it.\r\nexport function extractExtension(number)\r\n{\r\n\tconst start = number.search(EXTN_PATTERN)\r\n\tif (start < 0) {\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// If we find a potential extension, and the number preceding this is a viable\r\n\t// number, we assume it is an extension.\r\n\tconst number_without_extension = number.slice(0, start)\r\n\r\n\tconst matches = number.match(EXTN_PATTERN)\r\n\tlet i = 1\r\n\twhile (i < matches.length)\r\n\t{\r\n\t\tif (matches[i] != null && matches[i].length > 0)\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tnumber : number_without_extension,\r\n\t\t\t\text    : matches[i]\r\n\t\t\t}\r\n\t\t}\r\n\t\ti++\r\n\t}\r\n}"]}