{"version":3,"file":"immer.umd.js","sources":["../src/patches.js","../src/common.js","../src/proxy.js","../src/es5.js","../src/immer.js"],"sourcesContent":["import {each} from \"./common\"\n\nexport function generatePatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    if (patches)\n        if (Array.isArray(baseValue))\n            generateArrayPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n        else\n            generateObjectPatches(\n                state,\n                basepath,\n                patches,\n                inversePatches,\n                baseValue,\n                resultValue\n            )\n}\n\nexport function generateArrayPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    const shared = Math.min(baseValue.length, resultValue.length)\n    for (let i = 0; i < shared; i++) {\n        if (state.assigned[i] && baseValue[i] !== resultValue[i]) {\n            const path = basepath.concat(i)\n            patches.push({op: \"replace\", path, value: resultValue[i]})\n            inversePatches.push({op: \"replace\", path, value: baseValue[i]})\n        }\n    }\n    if (shared < resultValue.length) {\n        // stuff was added\n        for (let i = shared; i < resultValue.length; i++) {\n            const path = basepath.concat(i)\n            patches.push({op: \"add\", path, value: resultValue[i]})\n        }\n        inversePatches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: baseValue.length\n        })\n    } else if (shared < baseValue.length) {\n        // stuff was removed\n        patches.push({\n            op: \"replace\",\n            path: basepath.concat(\"length\"),\n            value: resultValue.length\n        })\n        for (let i = shared; i < baseValue.length; i++) {\n            const path = basepath.concat(i)\n            inversePatches.push({op: \"add\", path, value: baseValue[i]})\n        }\n    }\n}\n\nfunction generateObjectPatches(\n    state,\n    basepath,\n    patches,\n    inversePatches,\n    baseValue,\n    resultValue\n) {\n    each(state.assigned, (key, assignedValue) => {\n        const origValue = baseValue[key]\n        const value = resultValue[key]\n        const op = !assignedValue\n            ? \"remove\"\n            : key in baseValue ? \"replace\" : \"add\"\n        if (origValue === baseValue && op === \"replace\") return\n        const path = basepath.concat(key)\n        patches.push(op === \"remove\" ? {op, path} : {op, path, value})\n        inversePatches.push(\n            op === \"add\"\n                ? {op: \"remove\", path}\n                : op === \"remove\"\n                  ? {op: \"add\", path, value: origValue}\n                  : {op: \"replace\", path, value: origValue}\n        )\n    })\n}\n\nexport function applyPatches(draft, patches) {\n    for (let i = 0; i < patches.length; i++) {\n        const patch = patches[i]\n        if (patch.path.length === 0 && patch.op === \"replace\") {\n            draft = patch.value\n        } else {\n            const path = patch.path.slice()\n            const key = path.pop()\n            const base = path.reduce((current, part) => {\n                if (!current)\n                    throw new Error(\n                        \"Cannot apply patch, path doesn't resolve: \" +\n                            patch.path.join(\"/\")\n                    )\n                return current[part]\n            }, draft)\n            if (!base)\n                throw new Error(\n                    \"Cannot apply patch, path doesn't resolve: \" +\n                        patch.path.join(\"/\")\n                )\n            switch (patch.op) {\n                case \"replace\":\n                case \"add\":\n                    // TODO: add support is not extensive, it does not support insertion or `-` atm!\n                    base[key] = patch.value\n                    break\n                case \"remove\":\n                    if (Array.isArray(base)) {\n                        if (key === base.length - 1) base.length -= 1\n                        else\n                            throw new Error(\n                                `Remove can only remove the last key of an array, index: ${key}, length: ${\n                                    base.length\n                                }`\n                            )\n                    } else delete base[key]\n                    break\n                default:\n                    throw new Error(\"Unsupported patch operation: \" + patch.op)\n            }\n        }\n    }\n    return draft\n}\n","import {generatePatches} from \"./patches\"\n\nexport const PROXY_STATE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-proxy-state\")\n        : \"__$immer_state\"\n\nexport const RETURNED_AND_MODIFIED_ERROR =\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n\nfunction verifyMinified() {}\n\nconst inProduction =\n    (typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\") ||\n    verifyMinified.name !== \"verifyMinified\"\n\nlet autoFreeze = !inProduction\nlet useProxies = typeof Proxy !== \"undefined\"\n\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\nexport function setAutoFreeze(enableAutoFreeze) {\n    autoFreeze = enableAutoFreeze\n}\n\nexport function setUseProxies(value) {\n    useProxies = value\n}\n\nexport function getUseProxies() {\n    return useProxies\n}\n\nexport function isProxy(value) {\n    return !!value && !!value[PROXY_STATE]\n}\n\nexport function isProxyable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function freeze(value) {\n    if (autoFreeze) {\n        Object.freeze(value)\n    }\n    return value\n}\n\nconst assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    const target = value.__proto__ === undefined ? Object.create(null) : {}\n    return assign(target, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i])\n    } else {\n        for (let key in value) cb(key, value[key])\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n// given a base object, returns it if unmodified, or return the changed cloned if modified\nexport function finalize(base, path, patches, inversePatches) {\n    if (isProxy(base)) {\n        const state = base[PROXY_STATE]\n        if (state.modified === true) {\n            if (state.finalized === true) return state.copy\n            state.finalized = true\n            const result = finalizeObject(\n                useProxies ? state.copy : (state.copy = shallowCopy(base)),\n                state,\n                path,\n                patches,\n                inversePatches\n            )\n            generatePatches(\n                state,\n                path,\n                patches,\n                inversePatches,\n                state.base,\n                result\n            )\n            return result\n        } else {\n            return state.base\n        }\n    }\n    finalizeNonProxiedObject(base)\n    return base\n}\n\nfunction finalizeObject(copy, state, path, patches, inversePatches) {\n    const base = state.base\n    each(copy, (prop, value) => {\n        if (value !== base[prop]) {\n            // if there was an assignment on this property, we don't need to generate\n            // patches for the subtree\n            const generatePatches = patches && !has(state.assigned, prop)\n            copy[prop] = finalize(\n                value,\n                generatePatches && path.concat(prop),\n                generatePatches && patches,\n                inversePatches\n            )\n        }\n    })\n    return freeze(copy)\n}\n\nfunction finalizeNonProxiedObject(parent) {\n    // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n    // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n    if (!isProxyable(parent)) return\n    if (Object.isFrozen(parent)) return\n    each(parent, (i, child) => {\n        if (isProxy(child)) {\n            parent[i] = finalize(child)\n        } else finalizeNonProxiedObject(child)\n    })\n    // always freeze completely new data\n    freeze(parent)\n}\n\nexport function verifyReturnValue(returnedValue, proxy, isProxyModified) {\n    if (returnedValue !== undefined && returnedValue !== proxy) {\n        // something was returned, and it wasn't the proxy itself\n        if (isProxyModified)\n            throw new Error(\n                \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n            )\n    }\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    has,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    finalize,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each\n} from \"./common\"\n\nlet proxies = null\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\n\nfunction createState(parent, base) {\n    return {\n        modified: false, // this tree is modified (either this object or one of it's children)\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        finalized: false,\n        parent,\n        base,\n        copy: undefined,\n        proxies: {}\n    }\n}\n\nfunction source(state) {\n    return state.modified === true ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    if (prop === PROXY_STATE) return state\n    if (state.modified) {\n        const value = state.copy[prop]\n        if (value === state.base[prop] && isProxyable(value))\n            // only create proxy if it is not yet a proxy, and not a new object\n            // (new objects don't need proxying, they will be processed in finalize anyway)\n            return (state.copy[prop] = createProxy(state, value))\n        return value\n    } else {\n        if (has(state.proxies, prop)) return state.proxies[prop]\n        const value = state.base[prop]\n        if (!isProxy(value) && isProxyable(value))\n            return (state.proxies[prop] = createProxy(state, value))\n        return value\n    }\n}\n\nfunction set(state, prop, value) {\n    // TODO: optimize\n    state.assigned[prop] = true\n    if (!state.modified) {\n        if (\n            (prop in state.base && is(state.base[prop], value)) ||\n            (has(state.proxies, prop) && state.proxies[prop] === value)\n        )\n            return true\n        markChanged(state)\n    }\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    state.assigned[prop] = false\n    markChanged(state)\n    delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.proxies, prop) ? state.proxies : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does not support defining properties on draft objects.\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = shallowCopy(state.base)\n        // copy the proxies over the base-copy\n        Object.assign(state.copy, state.proxies) // yup that works for arrays as well\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parentState, base, key) {\n    if (isProxy(base)) throw new Error(\"Immer bug. Plz report.\")\n    const state = createState(parentState, base, key)\n    const proxy = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n    proxies.push(proxy)\n    return proxy.proxy\n}\n\nexport function produceProxy(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const previousProxies = proxies\n    proxies = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n\n            // See #117\n            // Should we just throw when returning a proxy which is not the root, but a subset of the original state?\n            // Looks like a wrongly modeled reducer\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // revoke all proxies\n        each(proxies, (_, p) => p.revoke())\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        proxies = previousProxies\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each,\n    finalize\n} from \"./common\"\n\nconst descriptors = {}\nlet states = null\n\nfunction createState(parent, proxy, base) {\n    return {\n        modified: false,\n        assigned: {}, // true: value was assigned to these props, false: was removed\n        hasCopy: false,\n        parent,\n        base,\n        proxy,\n        copy: undefined,\n        finished: false,\n        finalizing: false,\n        finalized: false\n    }\n}\n\nfunction source(state) {\n    return state.hasCopy ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    assertUnfinished(state)\n    const value = source(state)[prop]\n    if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n        // only create a proxy if the value is proxyable, and the value was in the base state\n        // if it wasn't in the base state, the object is already modified and we will process it in finalize\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(state, value))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnfinished(state)\n    state.assigned[prop] = true // optimization; skip this if there is no listener\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (state.hasCopy) return\n    state.hasCopy = true\n    state.copy = shallowCopy(state.base)\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parent, base) {\n    const proxy = shallowCopy(base)\n    each(base, i => {\n        Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i))\n    })\n    const state = createState(parent, proxy, base)\n    createHiddenProperty(proxy, PROXY_STATE, state)\n    states.push(state)\n    return proxy\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[PROXY_STATE], prop)\n            },\n            set(value) {\n                set(this[PROXY_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnfinished(state) {\n    if (state.finished === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(state.copy || state.base)\n        )\n}\n\n// this sounds very expensive, but actually it is not that expensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\nfunction markChangesSweep() {\n    // intentionally we process the proxies in reverse order;\n    // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n    // reverse order of proxy creation approximates this\n    for (let i = states.length - 1; i >= 0; i--) {\n        const state = states[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction markChangesRecursively(object) {\n    if (!object || typeof object !== \"object\") return\n    const state = object[PROXY_STATE]\n    if (!state) return\n    const {proxy, base} = state\n    if (Array.isArray(object)) {\n        if (hasArrayChanges(state)) {\n            markChanged(state)\n            state.assigned.length = true\n            if (proxy.length < base.length)\n                for (let i = proxy.length; i < base.length; i++)\n                    state.assigned[i] = false\n            else\n                for (let i = base.length; i < proxy.length; i++)\n                    state.assigned[i] = true\n            each(proxy, (index, child) => {\n                if (!state.assigned[index]) markChangesRecursively(child)\n            })\n        }\n    } else {\n        const {added, removed} = diffKeys(base, proxy)\n        if (added.length > 0 || removed.length > 0) markChanged(state)\n        each(added, (_, key) => {\n            state.assigned[key] = true\n        })\n        each(removed, (_, key) => {\n            state.assigned[key] = false\n        })\n        each(proxy, (key, child) => {\n            if (!state.assigned[key]) markChangesRecursively(child)\n        })\n    }\n}\n\nfunction diffKeys(from, to) {\n    // TODO: optimize\n    const a = Object.keys(from)\n    const b = Object.keys(to)\n    return {\n        added: b.filter(key => a.indexOf(key) === -1),\n        removed: a.filter(key => b.indexOf(key) === -1)\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const baseKeys = Object.keys(state.base)\n    const keys = Object.keys(state.proxy)\n    return !shallowEqual(baseKeys, keys)\n}\n\nfunction hasArrayChanges(state) {\n    const {proxy} = state\n    if (proxy.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nexport function produceEs5(baseState, producer, patchListener) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const prevStates = states\n    states = []\n    const patches = patchListener && []\n    const inversePatches = patchListener && []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        each(states, (_, state) => {\n            state.finalizing = true\n        })\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n            result = finalize(returnValue)\n            if (patches) {\n                patches.push({op: \"replace\", path: [], value: result})\n                inversePatches.push({op: \"replace\", path: [], value: baseState})\n            }\n        } else {\n            if (patchListener) markChangesRecursively(rootProxy)\n            markChangesSweep() // this one is more efficient if we don't need to know which attributes have changed\n            result = finalize(rootProxy, [], patches, inversePatches)\n        }\n        // make sure all proxies become unusable\n        each(states, (_, state) => {\n            state.finished = true\n        })\n        patchListener && patchListener(patches, inversePatches)\n        return result\n    } finally {\n        states = prevStates\n    }\n}\n\nfunction shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (\n        typeof objA !== \"object\" ||\n        objA === null ||\n        typeof objB !== \"object\" ||\n        objB === null\n    ) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (\n            !hasOwnProperty.call(objB, keysA[i]) ||\n            !is(objA[keysA[i]], objB[keysA[i]])\n        ) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","export {setAutoFreeze, setUseProxies} from \"./common\"\n\nimport {applyPatches as applyPatchesImpl} from \"./patches\"\nimport {isProxyable, getUseProxies} from \"./common\"\nimport {produceProxy} from \"./proxy\"\nimport {produceEs5} from \"./es5\"\n\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produces here\n * @returns {any} a new state, or the base state if nothing was modified\n */\nexport function produce(baseState, producer, patchListener) {\n    // prettier-ignore\n    if (arguments.length < 1 || arguments.length > 3) throw new Error(\"produce expects 1 to 3 arguments, got \" + arguments.length)\n\n    // curried invocation\n    if (typeof baseState === \"function\") {\n        // prettier-ignore\n        if (typeof producer === \"function\") throw new Error(\"if first argument is a function (curried invocation), the second argument to produce cannot be a function\")\n\n        const initialState = producer\n        const recipe = baseState\n\n        return function() {\n            const args = arguments\n\n            const currentState =\n                args[0] === undefined && initialState !== undefined\n                    ? initialState\n                    : args[0]\n\n            return produce(currentState, draft => {\n                args[0] = draft // blegh!\n                return recipe.apply(draft, args)\n            })\n        }\n    }\n\n    // prettier-ignore\n    {\n        if (typeof producer !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n        if (patchListener !== undefined && typeof patchListener !== \"function\") throw new Error(\"the third argument of a producer should not be set or a function\")\n    }\n\n    // if state is a primitive, don't bother proxying at all\n    if (typeof baseState !== \"object\" || baseState === null) {\n        const returnValue = producer(baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n\n    if (!isProxyable(baseState))\n        throw new Error(\n            `the first argument to an immer producer should be a primitive, plain object or array, got ${typeof baseState}: \"${baseState}\"`\n        )\n    return getUseProxies()\n        ? produceProxy(baseState, producer, patchListener)\n        : produceEs5(baseState, producer, patchListener)\n}\n\nexport default produce\n\nexport const applyPatches = produce(applyPatchesImpl)\n"],"names":["generatePatches","state","basepath","patches","inversePatches","baseValue","resultValue","Array","isArray","shared","Math","min","length","i","assigned","path","concat","push","op","value","generateArrayPatches","key","assignedValue","origValue","PROXY_STATE","Symbol","RETURNED_AND_MODIFIED_ERROR","autoFreeze","process","env","NODE_ENV","name","useProxies","Proxy","isProxy","isProxyable","proto","Object","getPrototypeOf","prototype","freeze","assign","target","has","shallowCopy","slice","undefined","__proto__","create","each","cb","thing","prop","hasOwnProperty","call","finalize","base","modified","finalized","copy","result","finalizeNonProxiedObject","parent","isFrozen","child","is","x","y","proxies","objectTraps","createProxy","source","Reflect","ownKeys","owner","descriptor","getOwnPropertyDescriptor","configurable","Error","arrayTraps","markChanged","parentState","proxy","revocable","fn","arguments","apply","this","descriptors","states","hasCopy","prepareCopy","defineProperty","finalizing","get","assertUnfinished","finished","JSON","stringify","markChangesRecursively","object","from","to","a","b","hasArrayChanges","index","keys","filter","indexOf","added","removed","_","produceEs5","baseState","producer","patchListener","returnValue","prevStates","rootProxy","baseKeys","objA","objB","keysA","keysB","shallowEqual","produce","initialState","recipe","args","draft","previousProxies","p","revoke","produceProxy","applyPatches","patch","pop","reduce","current","part","join","enableAutoFreeze"],"mappings":"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"}